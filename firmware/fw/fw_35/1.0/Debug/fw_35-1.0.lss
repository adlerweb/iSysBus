
fw_35-1.0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000034  00800100  00000e50  00000ec4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e50  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000090  00800134  00000e84  00000ef8  2**0
                  ALLOC
  3 .stab         000032ac  00000000  00000000  00000ef8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000017f8  00000000  00000000  000041a4  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 38 00 	jmp	0x70	; 0x70 <__ctors_end>
   4:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
   8:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
   c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  10:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  14:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  18:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  1c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  20:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  24:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  28:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  2c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  30:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  34:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  38:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  3c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  40:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  44:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  48:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  4c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  50:	0c 94 57 01 	jmp	0x2ae	; 0x2ae <__vector_20>
  54:	0c 94 96 01 	jmp	0x32c	; 0x32c <__vector_21>
  58:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  5c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  60:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  64:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  68:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>
  6c:	0c 94 55 00 	jmp	0xaa	; 0xaa <__bad_interrupt>

00000070 <__ctors_end>:
  70:	11 24       	eor	r1, r1
  72:	1f be       	out	0x3f, r1	; 63
  74:	cf ef       	ldi	r28, 0xFF	; 255
  76:	d0 e1       	ldi	r29, 0x10	; 16
  78:	de bf       	out	0x3e, r29	; 62
  7a:	cd bf       	out	0x3d, r28	; 61

0000007c <__do_copy_data>:
  7c:	11 e0       	ldi	r17, 0x01	; 1
  7e:	a0 e0       	ldi	r26, 0x00	; 0
  80:	b1 e0       	ldi	r27, 0x01	; 1
  82:	e0 e5       	ldi	r30, 0x50	; 80
  84:	fe e0       	ldi	r31, 0x0E	; 14
  86:	02 c0       	rjmp	.+4      	; 0x8c <.do_copy_data_start>

00000088 <.do_copy_data_loop>:
  88:	05 90       	lpm	r0, Z+
  8a:	0d 92       	st	X+, r0

0000008c <.do_copy_data_start>:
  8c:	a4 33       	cpi	r26, 0x34	; 52
  8e:	b1 07       	cpc	r27, r17
  90:	d9 f7       	brne	.-10     	; 0x88 <.do_copy_data_loop>

00000092 <__do_clear_bss>:
  92:	11 e0       	ldi	r17, 0x01	; 1
  94:	a4 e3       	ldi	r26, 0x34	; 52
  96:	b1 e0       	ldi	r27, 0x01	; 1
  98:	01 c0       	rjmp	.+2      	; 0x9c <.do_clear_bss_start>

0000009a <.do_clear_bss_loop>:
  9a:	1d 92       	st	X+, r1

0000009c <.do_clear_bss_start>:
  9c:	a4 3c       	cpi	r26, 0xC4	; 196
  9e:	b1 07       	cpc	r27, r17
  a0:	e1 f7       	brne	.-8      	; 0x9a <.do_clear_bss_loop>
  a2:	0e 94 0d 06 	call	0xc1a	; 0xc1a <main>
  a6:	0c 94 26 07 	jmp	0xe4c	; 0xe4c <_exit>

000000aa <__bad_interrupt>:
  aa:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>

000000ae <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
  ae:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
  b0:	f9 99       	sbic	0x1f, 1	; 31
  b2:	fe cf       	rjmp	.-4      	; 0xb0 <eeprom_read_byte+0x2>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
  b4:	32 bd       	out	0x22, r19	; 34
  b6:	21 bd       	out	0x21, r18	; 33
#endif
    EECR |= (1 << EERE);
  b8:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
  ba:	80 b5       	in	r24, 0x20	; 32
}
  bc:	08 95       	ret

000000be <lib_eep_read_byte>:
#ifndef LIB_EEP_C_
	#define LIB_EEP_C_



	uint8_t __attribute__((always_inline)) lib_eep_read_byte(uint8_t * aAddr) {
  be:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
  c0:	f9 99       	sbic	0x1f, 1	; 31
  c2:	fe cf       	rjmp	.-4      	; 0xc0 <lib_eep_read_byte+0x2>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
  c4:	32 bd       	out	0x22, r19	; 34
  c6:	21 bd       	out	0x21, r18	; 33
#endif
    EECR |= (1 << EERE);
  c8:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
  ca:	80 b5       	in	r24, 0x20	; 32
		return eeprom_read_byte(aAddr);;
	}
  cc:	08 95       	ret

000000ce <lib_eep_write_byte>:
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
  ce:	f9 99       	sbic	0x1f, 1	; 31
  d0:	fe cf       	rjmp	.-4      	; 0xce <lib_eep_write_byte>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
  d2:	9c 01       	movw	r18, r24
  d4:	92 bd       	out	0x22, r25	; 34
  d6:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
  d8:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
  da:	80 b5       	in	r24, 0x20	; 32
	}



	void __attribute__((always_inline)) lib_eep_write_byte(uint8_t * aAddr, uint8_t aData) {
		if (eeprom_read_byte(aAddr) != aData) {
  dc:	86 17       	cp	r24, r22
  de:	59 f0       	breq	.+22     	; 0xf6 <lib_eep_write_byte+0x28>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
  e0:	f9 99       	sbic	0x1f, 1	; 31
  e2:	fe cf       	rjmp	.-4      	; 0xe0 <lib_eep_write_byte+0x12>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
  e4:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
  e6:	32 bd       	out	0x22, r19	; 34
  e8:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
  ea:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
  ec:	0f b6       	in	r0, 0x3f	; 63
  ee:	f8 94       	cli
  f0:	fa 9a       	sbi	0x1f, 2	; 31
  f2:	f9 9a       	sbi	0x1f, 1	; 31
  f4:	0f be       	out	0x3f, r0	; 63
  f6:	08 95       	ret

000000f8 <lib_eep_fw_read_byte>:
	}



	uint8_t __attribute__((always_inline)) lib_eep_fw_read_byte(uint8_t * aAddr) {
		return eeprom_read_byte(Isb_Firmware_Offset + aAddr);;
  f8:	20 91 36 01 	lds	r18, 0x0136
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
  fc:	f9 99       	sbic	0x1f, 1	; 31
  fe:	fe cf       	rjmp	.-4      	; 0xfc <lib_eep_fw_read_byte+0x4>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 100:	82 0f       	add	r24, r18
 102:	91 1d       	adc	r25, r1
 104:	92 bd       	out	0x22, r25	; 34
 106:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 108:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 10a:	80 b5       	in	r24, 0x20	; 32
	}
 10c:	08 95       	ret

0000010e <lib_eep_fw_write_byte>:
		return eeprom_read_word(Isb_Firmware_Offset + aAddr);;
	}



	void __attribute__((always_inline)) lib_eep_fw_write_byte(uint8_t * aAddr, uint8_t aData) {
 10e:	ac 01       	movw	r20, r24
		if (eeprom_read_byte(Isb_Firmware_Offset + aAddr) != aData) {
 110:	80 91 36 01 	lds	r24, 0x0136
 114:	28 2f       	mov	r18, r24
 116:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 118:	f9 99       	sbic	0x1f, 1	; 31
 11a:	fe cf       	rjmp	.-4      	; 0x118 <lib_eep_fw_write_byte+0xa>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 11c:	ca 01       	movw	r24, r20
 11e:	82 0f       	add	r24, r18
 120:	93 1f       	adc	r25, r19
 122:	92 bd       	out	0x22, r25	; 34
 124:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 126:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 128:	80 b5       	in	r24, 0x20	; 32
 12a:	86 17       	cp	r24, r22
 12c:	69 f0       	breq	.+26     	; 0x148 <lib_eep_fw_write_byte+0x3a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 12e:	f9 99       	sbic	0x1f, 1	; 31
 130:	fe cf       	rjmp	.-4      	; 0x12e <lib_eep_fw_write_byte+0x20>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 132:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 134:	24 0f       	add	r18, r20
 136:	35 1f       	adc	r19, r21
 138:	32 bd       	out	0x22, r19	; 34
 13a:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
 13c:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
 13e:	0f b6       	in	r0, 0x3f	; 63
 140:	f8 94       	cli
 142:	fa 9a       	sbi	0x1f, 2	; 31
 144:	f9 9a       	sbi	0x1f, 1	; 31
 146:	0f be       	out	0x3f, r0	; 63
 148:	08 95       	ret

0000014a <Lib_Pin_Get>:
	#endif



	uint8_t Lib_Pin_Get(const uint8_t aPort, const uint8_t aPin) {
		return (*(PINx[aPort]) >> aPin) & 1;
 14a:	e8 2f       	mov	r30, r24
 14c:	f0 e0       	ldi	r31, 0x00	; 0
 14e:	ee 0f       	add	r30, r30
 150:	ff 1f       	adc	r31, r31
 152:	ec 5d       	subi	r30, 0xDC	; 220
 154:	fe 4f       	sbci	r31, 0xFE	; 254
 156:	01 90       	ld	r0, Z+
 158:	f0 81       	ld	r31, Z
 15a:	e0 2d       	mov	r30, r0
 15c:	80 81       	ld	r24, Z
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	02 c0       	rjmp	.+4      	; 0x166 <Lib_Pin_Get+0x1c>
 162:	95 95       	asr	r25
 164:	87 95       	ror	r24
 166:	6a 95       	dec	r22
 168:	e2 f7       	brpl	.-8      	; 0x162 <Lib_Pin_Get+0x18>
	}
 16a:	81 70       	andi	r24, 0x01	; 1
 16c:	08 95       	ret

0000016e <Lib_Pin_Set>:



	void __attribute__((noinline)) Lib_Pin_Set(const uint8_t aPort, const uint8_t aPin, const uint8_t aCmd) {
 16e:	91 e0       	ldi	r25, 0x01	; 1
 170:	02 c0       	rjmp	.+4      	; 0x176 <Lib_Pin_Set+0x8>
		uint8_t mask;
		uint8_t tmp;
		volatile uint8_t *reg;
		uint8_t Pxx = aPin;
		for (mask = 1; Pxx--; mask <<= 1) ;
 172:	99 0f       	add	r25, r25
 174:	61 50       	subi	r22, 0x01	; 1
 176:	66 23       	and	r22, r22
 178:	e1 f7       	brne	.-8      	; 0x172 <Lib_Pin_Set+0x4>
		reg = PORTx[aPort];
 17a:	a8 2f       	mov	r26, r24
 17c:	b0 e0       	ldi	r27, 0x00	; 0
 17e:	fd 01       	movw	r30, r26
 180:	ee 0f       	add	r30, r30
 182:	ff 1f       	adc	r31, r31
 184:	ec 5e       	subi	r30, 0xEC	; 236
 186:	fe 4f       	sbci	r31, 0xFE	; 254
 188:	01 90       	ld	r0, Z+
 18a:	f0 81       	ld	r31, Z
 18c:	e0 2d       	mov	r30, r0
		tmp = *reg | mask;
 18e:	80 81       	ld	r24, Z
 190:	89 2b       	or	r24, r25
		if (! (aCmd & 2)) {
 192:	41 ff       	sbrs	r20, 1
			tmp ^= mask;
 194:	89 27       	eor	r24, r25
		}
		*reg = tmp;
 196:	80 83       	st	Z, r24
		reg = DDRx[aPort];
 198:	aa 0f       	add	r26, r26
 19a:	bb 1f       	adc	r27, r27
 19c:	ac 5f       	subi	r26, 0xFC	; 252
 19e:	be 4f       	sbci	r27, 0xFE	; 254
 1a0:	ed 91       	ld	r30, X+
 1a2:	fc 91       	ld	r31, X
		tmp = *reg | mask;
 1a4:	80 81       	ld	r24, Z
 1a6:	89 2b       	or	r24, r25
		if (! (aCmd & 1)) {
 1a8:	40 ff       	sbrs	r20, 0
			tmp ^= mask;
 1aa:	89 27       	eor	r24, r25
		}
		*reg = tmp;
 1ac:	80 83       	st	Z, r24
	}
 1ae:	08 95       	ret

000001b0 <Lib_Crc_Calc8>:
#ifndef LIB_CRC_C_
	#define LIB_CRC_C_



	uint8_t Lib_Crc_Calc8(const void * aData, uint16_t aLength) {
 1b0:	dc 01       	movw	r26, r24
 1b2:	40 e0       	ldi	r20, 0x00	; 0
 1b4:	20 e0       	ldi	r18, 0x00	; 0
 1b6:	30 e0       	ldi	r19, 0x00	; 0
 1b8:	07 c0       	rjmp	.+14     	; 0x1c8 <Lib_Crc_Calc8+0x18>
		uint8_t Sum = 0;
		for (uint16_t i = 0; i < aLength; i++) {
			Sum += *(uint8_t *)(aData + i);
 1ba:	fd 01       	movw	r30, r26
 1bc:	e2 0f       	add	r30, r18
 1be:	f3 1f       	adc	r31, r19
 1c0:	80 81       	ld	r24, Z
 1c2:	48 0f       	add	r20, r24



	uint8_t Lib_Crc_Calc8(const void * aData, uint16_t aLength) {
		uint8_t Sum = 0;
		for (uint16_t i = 0; i < aLength; i++) {
 1c4:	2f 5f       	subi	r18, 0xFF	; 255
 1c6:	3f 4f       	sbci	r19, 0xFF	; 255
 1c8:	26 17       	cp	r18, r22
 1ca:	37 07       	cpc	r19, r23
 1cc:	b0 f3       	brcs	.-20     	; 0x1ba <Lib_Crc_Calc8+0xa>
			Sum += *(uint8_t *)(aData + i);
		}
		return (uint8_t)((Sum ^ 0xFF) + 1);
	}
 1ce:	84 2f       	mov	r24, r20
 1d0:	81 95       	neg	r24
 1d2:	08 95       	ret

000001d4 <Lib_Crc_Calc16>:



	uint16_t Lib_Crc_Calc16(const void * aData, uint16_t aLength) {
 1d4:	0f 93       	push	r16
 1d6:	1f 93       	push	r17
 1d8:	cf 93       	push	r28
 1da:	df 93       	push	r29
 1dc:	8c 01       	movw	r16, r24
 1de:	ec 01       	movw	r28, r24
 1e0:	fb 01       	movw	r30, r22
 1e2:	20 e0       	ldi	r18, 0x00	; 0
 1e4:	30 e0       	ldi	r19, 0x00	; 0
 1e6:	40 e0       	ldi	r20, 0x00	; 0
 1e8:	50 e0       	ldi	r21, 0x00	; 0
		uint32_t Sum = 0;
		while (1) {
			if (aLength < 2) {
 1ea:	e2 30       	cpi	r30, 0x02	; 2
 1ec:	f1 05       	cpc	r31, r1
 1ee:	50 f0       	brcs	.+20     	; 0x204 <Lib_Crc_Calc16+0x30>
				break;
			}
			Sum += *((uint16_t *)aData);
 1f0:	89 91       	ld	r24, Y+
 1f2:	99 91       	ld	r25, Y+
 1f4:	a0 e0       	ldi	r26, 0x00	; 0
 1f6:	b0 e0       	ldi	r27, 0x00	; 0
 1f8:	28 0f       	add	r18, r24
 1fa:	39 1f       	adc	r19, r25
 1fc:	4a 1f       	adc	r20, r26
 1fe:	5b 1f       	adc	r21, r27
			aData += 2;
			aLength -= 2;
 200:	32 97       	sbiw	r30, 0x02	; 2
 202:	f3 cf       	rjmp	.-26     	; 0x1ea <Lib_Crc_Calc16+0x16>
		}
 204:	fb 01       	movw	r30, r22
 206:	ee 7f       	andi	r30, 0xFE	; 254
 208:	e0 0f       	add	r30, r16
 20a:	f1 1f       	adc	r31, r17
		if (aLength) {
 20c:	60 ff       	sbrs	r22, 0
 20e:	0b c0       	rjmp	.+22     	; 0x226 <Lib_Crc_Calc16+0x52>
			Sum += *(uint8_t *) aData;
 210:	80 81       	ld	r24, Z
 212:	28 0f       	add	r18, r24
 214:	31 1d       	adc	r19, r1
 216:	41 1d       	adc	r20, r1
 218:	51 1d       	adc	r21, r1
 21a:	05 c0       	rjmp	.+10     	; 0x226 <Lib_Crc_Calc16+0x52>
		}
		while ((aLength = (uint16_t) (Sum >> 16)) != 0) {
			Sum = (uint16_t) Sum + aLength;
 21c:	62 0f       	add	r22, r18
 21e:	73 1f       	adc	r23, r19
 220:	9b 01       	movw	r18, r22
 222:	40 e0       	ldi	r20, 0x00	; 0
 224:	50 e0       	ldi	r21, 0x00	; 0
			aLength -= 2;
		}
		if (aLength) {
			Sum += *(uint8_t *) aData;
		}
		while ((aLength = (uint16_t) (Sum >> 16)) != 0) {
 226:	ca 01       	movw	r24, r20
 228:	aa 27       	eor	r26, r26
 22a:	bb 27       	eor	r27, r27
 22c:	bc 01       	movw	r22, r24
 22e:	89 2b       	or	r24, r25
 230:	a9 f7       	brne	.-22     	; 0x21c <Lib_Crc_Calc16+0x48>
 232:	20 95       	com	r18
 234:	30 95       	com	r19
			Sum = (uint16_t) Sum + aLength;
		}
		return (uint16_t) Sum ^ 0xFFFF;
	}
 236:	c9 01       	movw	r24, r18
 238:	df 91       	pop	r29
 23a:	cf 91       	pop	r28
 23c:	1f 91       	pop	r17
 23e:	0f 91       	pop	r16
 240:	08 95       	ret

00000242 <Inf_Usart_Init>:
	#define INF_USART_C_



	#if defined(INF_USART0_TX) || defined(INF_USART0_RX) || defined(INF_USART1_TX) || defined(INF_USART1_RX)
		uint8_t Inf_Usart_Init(const uint8_t aInf, const uint8_t aUbrrl, const uint8_t aUbrrh, const uint8_t aUcsra, const uint8_t aUcsrb, const uint8_t aUcsrc) {
 242:	ef 92       	push	r14
 244:	0f 93       	push	r16
			uint8_t Result = FALSE;
			switch (aInf) {
 246:	88 23       	and	r24, r24
 248:	11 f0       	breq	.+4      	; 0x24e <Inf_Usart_Init+0xc>
 24a:	80 e0       	ldi	r24, 0x00	; 0
 24c:	13 c0       	rjmp	.+38     	; 0x274 <Inf_Usart_Init+0x32>
				#if defined(INF_USART0_RX) || defined(INF_USART0_TX)
					case 0:
						#if defined(INF_USART0_RX)
							Inf_Usart_Rx0_Buffer_Tail = Inf_Usart_Rx0_Buffer_Head;
 24e:	80 91 39 01 	lds	r24, 0x0139
 252:	80 93 3a 01 	sts	0x013A, r24
						#endif /* INF_USART0_RX */
						#if defined(INF_USART0_TX)
							Inf_Usart_Tx0_Buffer_Tail = Inf_Usart_Tx0_Buffer_Head;
 256:	80 91 42 01 	lds	r24, 0x0142
 25a:	80 93 41 01 	sts	0x0141, r24
							UBRR0L = aUbrrl;
							UCSR0C = aUcsrc;
							UCSR0B = aUcsrb;
							Result = TRUE;
						#elif defined(__AVR_ATmega644__)
							UCSR0A = aUcsra;
 25e:	20 93 c0 00 	sts	0x00C0, r18
							UBRR0H = aUbrrh;
 262:	40 93 c5 00 	sts	0x00C5, r20
							UBRR0L = aUbrrl;
 266:	60 93 c4 00 	sts	0x00C4, r22
							UCSR0C = aUcsrc;
 26a:	e0 92 c2 00 	sts	0x00C2, r14
							UCSR0B = aUcsrb;
 26e:	00 93 c1 00 	sts	0x00C1, r16
 272:	81 e0       	ldi	r24, 0x01	; 1
						#endif
						break;
				#endif /* INF_USART1_RX || INF_USART1_TX */
			}
			return Result;
		}
 274:	0f 91       	pop	r16
 276:	ef 90       	pop	r14
 278:	08 95       	ret

0000027a <Inf_Usart_Rx>:
	#endif /* INF_USART0_TX || INF_USART0_RX || INF_USART1_TX || INF_USART1_RX*/



	#if defined(INF_USART0_RX) || defined(INF_USART1_RX)
		uint8_t Inf_Usart_Rx(const uint8_t aInf, uint8_t * aChar) {
 27a:	db 01       	movw	r26, r22
			uint8_t Result = FALSE;
			switch (aInf) {
 27c:	88 23       	and	r24, r24
 27e:	a9 f4       	brne	.+42     	; 0x2aa <Inf_Usart_Rx+0x30>
				#if defined(INF_USART0_RX)
					case 0:
						if (Inf_Usart_Rx0_Buffer_Head != Inf_Usart_Rx0_Buffer_Tail) {
 280:	90 91 39 01 	lds	r25, 0x0139
 284:	80 91 3a 01 	lds	r24, 0x013A
 288:	98 17       	cp	r25, r24
 28a:	79 f0       	breq	.+30     	; 0x2aa <Inf_Usart_Rx+0x30>
							Inf_Usart_Rx0_Buffer_Tail = (Inf_Usart_Rx0_Buffer_Tail + 1) & INF_USART_RX0_BUFFER_MASK;
 28c:	80 91 3a 01 	lds	r24, 0x013A
 290:	8f 5f       	subi	r24, 0xFF	; 255
 292:	8f 73       	andi	r24, 0x3F	; 63
 294:	80 93 3a 01 	sts	0x013A, r24
							*aChar = Inf_Usart_Rx0_Buffer[Inf_Usart_Rx0_Buffer_Tail];
 298:	e0 91 3a 01 	lds	r30, 0x013A
 29c:	f0 e0       	ldi	r31, 0x00	; 0
 29e:	ed 5b       	subi	r30, 0xBD	; 189
 2a0:	fe 4f       	sbci	r31, 0xFE	; 254
 2a2:	80 81       	ld	r24, Z
 2a4:	8c 93       	st	X, r24
 2a6:	81 e0       	ldi	r24, 0x01	; 1
 2a8:	08 95       	ret
 2aa:	80 e0       	ldi	r24, 0x00	; 0
						}
						break;
				#endif /* INF_USART1_RX */
			}
			return Result;
		}
 2ac:	08 95       	ret

000002ae <__vector_20>:
					Inf_Usart_Rx0_Buffer[Tmp_Head] = UDR0;
					Inf_Usart_Rx0_Buffer_Head = Tmp_Head;
				}
			}
		#elif defined(__AVR_ATmega644__)
			ISR (USART0_RX_vect) {
 2ae:	1f 92       	push	r1
 2b0:	0f 92       	push	r0
 2b2:	0f b6       	in	r0, 0x3f	; 63
 2b4:	0f 92       	push	r0
 2b6:	11 24       	eor	r1, r1
 2b8:	8f 93       	push	r24
 2ba:	9f 93       	push	r25
 2bc:	ef 93       	push	r30
 2be:	ff 93       	push	r31
				uint8_t Tmp_Head;
				Tmp_Head = (Inf_Usart_Rx0_Buffer_Head + 1) & INF_USART_RX0_BUFFER_MASK;
 2c0:	90 91 39 01 	lds	r25, 0x0139
 2c4:	9f 5f       	subi	r25, 0xFF	; 255
 2c6:	9f 73       	andi	r25, 0x3F	; 63
				if (Tmp_Head != Inf_Usart_Rx0_Buffer_Tail) {
 2c8:	80 91 3a 01 	lds	r24, 0x013A
 2cc:	98 17       	cp	r25, r24
 2ce:	49 f0       	breq	.+18     	; 0x2e2 <__vector_20+0x34>
					Inf_Usart_Rx0_Buffer[Tmp_Head] = UDR0;
 2d0:	e9 2f       	mov	r30, r25
 2d2:	f0 e0       	ldi	r31, 0x00	; 0
 2d4:	80 91 c6 00 	lds	r24, 0x00C6
 2d8:	ed 5b       	subi	r30, 0xBD	; 189
 2da:	fe 4f       	sbci	r31, 0xFE	; 254
 2dc:	80 83       	st	Z, r24
					Inf_Usart_Rx0_Buffer_Head = Tmp_Head;
 2de:	90 93 39 01 	sts	0x0139, r25
				}
			}
 2e2:	ff 91       	pop	r31
 2e4:	ef 91       	pop	r30
 2e6:	9f 91       	pop	r25
 2e8:	8f 91       	pop	r24
 2ea:	0f 90       	pop	r0
 2ec:	0f be       	out	0x3f, r0	; 63
 2ee:	0f 90       	pop	r0
 2f0:	1f 90       	pop	r1
 2f2:	18 95       	reti

000002f4 <Inf_Usart_Tx>:
	#endif /* INF_USART1_RX */



	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
 2f4:	db 01       	movw	r26, r22
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 2f6:	88 23       	and	r24, r24
 2f8:	b9 f4       	brne	.+46     	; 0x328 <Inf_Usart_Tx+0x34>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 2fa:	90 91 42 01 	lds	r25, 0x0142
 2fe:	9f 5f       	subi	r25, 0xFF	; 255
 300:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 302:	80 91 41 01 	lds	r24, 0x0141
 306:	98 17       	cp	r25, r24
 308:	79 f0       	breq	.+30     	; 0x328 <Inf_Usart_Tx+0x34>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 30a:	e9 2f       	mov	r30, r25
 30c:	f0 e0       	ldi	r31, 0x00	; 0
 30e:	8c 91       	ld	r24, X
 310:	ed 57       	subi	r30, 0x7D	; 125
 312:	fe 4f       	sbci	r31, 0xFE	; 254
 314:	80 83       	st	Z, r24
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 316:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 31a:	80 91 c1 00 	lds	r24, 0x00C1
 31e:	80 62       	ori	r24, 0x20	; 32
 320:	80 93 c1 00 	sts	0x00C1, r24
 324:	81 e0       	ldi	r24, 0x01	; 1
 326:	08 95       	ret
 328:	80 e0       	ldi	r24, 0x00	; 0
						}
						break;
				#endif /* INF_USART1_TX */
			}
			return Result;
		}
 32a:	08 95       	ret

0000032c <__vector_21>:
				else {
					UCSR0B &= ~(1 << UDRIE0);
				}
			}
		#elif defined(__AVR_ATmega644__)
			ISR (USART0_UDRE_vect) {
 32c:	1f 92       	push	r1
 32e:	0f 92       	push	r0
 330:	0f b6       	in	r0, 0x3f	; 63
 332:	0f 92       	push	r0
 334:	11 24       	eor	r1, r1
 336:	8f 93       	push	r24
 338:	9f 93       	push	r25
 33a:	ef 93       	push	r30
 33c:	ff 93       	push	r31
				if (Inf_Usart_Tx0_Buffer_Head != Inf_Usart_Tx0_Buffer_Tail) {
 33e:	90 91 42 01 	lds	r25, 0x0142
 342:	80 91 41 01 	lds	r24, 0x0141
 346:	98 17       	cp	r25, r24
 348:	a1 f0       	breq	.+40     	; 0x372 <__vector_21+0x46>
					Inf_Usart_Tx0_Buffer_Tail = (Inf_Usart_Tx0_Buffer_Tail + 1) & INF_USART_TX0_BUFFER_MASK;
 34a:	80 91 41 01 	lds	r24, 0x0141
 34e:	8f 5f       	subi	r24, 0xFF	; 255
 350:	8f 73       	andi	r24, 0x3F	; 63
 352:	80 93 41 01 	sts	0x0141, r24
					UDR0 = Inf_Usart_Tx0_Buffer[Inf_Usart_Tx0_Buffer_Tail];
 356:	e0 91 41 01 	lds	r30, 0x0141
 35a:	f0 e0       	ldi	r31, 0x00	; 0
 35c:	ed 57       	subi	r30, 0x7D	; 125
 35e:	fe 4f       	sbci	r31, 0xFE	; 254
 360:	80 81       	ld	r24, Z
 362:	80 93 c6 00 	sts	0x00C6, r24
					UCSR0A |= (1 << TXC0);
 366:	80 91 c0 00 	lds	r24, 0x00C0
 36a:	80 64       	ori	r24, 0x40	; 64
 36c:	80 93 c0 00 	sts	0x00C0, r24
 370:	05 c0       	rjmp	.+10     	; 0x37c <__vector_21+0x50>
				}
				else {
					UCSR0B &= ~(1 << UDRIE0);
 372:	80 91 c1 00 	lds	r24, 0x00C1
 376:	8f 7d       	andi	r24, 0xDF	; 223
 378:	80 93 c1 00 	sts	0x00C1, r24
				}
			}
 37c:	ff 91       	pop	r31
 37e:	ef 91       	pop	r30
 380:	9f 91       	pop	r25
 382:	8f 91       	pop	r24
 384:	0f 90       	pop	r0
 386:	0f be       	out	0x3f, r0	; 63
 388:	0f 90       	pop	r0
 38a:	1f 90       	pop	r1
 38c:	18 95       	reti

0000038e <Isb_Inf_Usart_Init>:



	uint8_t Isb_Inf_Usart_Init(const uint8_t aInf) {
		uint8_t Result = FALSE;
		switch (aInf) {
 38e:	88 23       	and	r24, r24
 390:	11 f0       	breq	.+4      	; 0x396 <Isb_Inf_Usart_Init+0x8>
 392:	80 e0       	ldi	r24, 0x00	; 0
 394:	08 95       	ret
			uint8_t Result = FALSE;
			switch (aInf) {
				#if defined(INF_USART0_RX) || defined(INF_USART0_TX)
					case 0:
						#if defined(INF_USART0_RX)
							Inf_Usart_Rx0_Buffer_Tail = Inf_Usart_Rx0_Buffer_Head;
 396:	80 91 39 01 	lds	r24, 0x0139
 39a:	80 93 3a 01 	sts	0x013A, r24
						#endif /* INF_USART0_RX */
						#if defined(INF_USART0_TX)
							Inf_Usart_Tx0_Buffer_Tail = Inf_Usart_Tx0_Buffer_Head;
 39e:	80 91 42 01 	lds	r24, 0x0142
 3a2:	80 93 41 01 	sts	0x0141, r24
							UBRR0L = aUbrrl;
							UCSR0C = aUcsrc;
							UCSR0B = aUcsrb;
							Result = TRUE;
						#elif defined(__AVR_ATmega644__)
							UCSR0A = aUcsra;
 3a6:	83 e0       	ldi	r24, 0x03	; 3
 3a8:	80 93 c0 00 	sts	0x00C0, r24
							UBRR0H = aUbrrh;
 3ac:	10 92 c5 00 	sts	0x00C5, r1
							UBRR0L = aUbrrl;
 3b0:	80 e1       	ldi	r24, 0x10	; 16
 3b2:	80 93 c4 00 	sts	0x00C4, r24
							UCSR0C = aUcsrc;
 3b6:	86 e0       	ldi	r24, 0x06	; 6
 3b8:	80 93 c2 00 	sts	0x00C2, r24
							UCSR0B = aUcsrb;
 3bc:	88 eb       	ldi	r24, 0xB8	; 184
 3be:	80 93 c1 00 	sts	0x00C1, r24
 3c2:	81 e0       	ldi	r24, 0x01	; 1
					Result = Inf_Usart_Init(1, INF_USART1_UBRRL, INF_USART1_UBRRH, INF_USART1_UCSRA, INF_USART1_UCSRB, INF_USART1_UCSRC);
				break;
			#endif /* ISB_INF_USART1 == 1 */
		}
		return Result;
	}
 3c4:	08 95       	ret

000003c6 <Isb_Inf_Usart_Tx>:



	uint8_t Isb_Inf_Usart_Tx(const uint8_t aInf, const Isb_Msg_t * aIsb_Msg) {
 3c6:	ff 92       	push	r15
 3c8:	0f 93       	push	r16
 3ca:	1f 93       	push	r17
 3cc:	cf 93       	push	r28
 3ce:	df 93       	push	r29
 3d0:	58 2f       	mov	r21, r24
 3d2:	eb 01       	movw	r28, r22
		uint8_t Result = FALSE;
		uint8_t Free_Space = 0;
		uint8_t Startbyte = 0;
		uint8_t Stopbyte = 0;
		switch (aInf) {
 3d4:	88 23       	and	r24, r24
 3d6:	21 f0       	breq	.+8      	; 0x3e0 <Isb_Inf_Usart_Tx+0x1a>
 3d8:	20 e0       	ldi	r18, 0x00	; 0
 3da:	40 e0       	ldi	r20, 0x00	; 0
 3dc:	ff 24       	eor	r15, r15
 3de:	16 c0       	rjmp	.+44     	; 0x40c <Isb_Inf_Usart_Tx+0x46>
			#if defined(INF_USART0_TX)
				case 0:
					cli();
 3e0:	f8 94       	cli
					if (Inf_Usart_Tx0_Buffer_Tail > Inf_Usart_Tx0_Buffer_Head) {
 3e2:	90 91 41 01 	lds	r25, 0x0141
 3e6:	80 91 42 01 	lds	r24, 0x0142
 3ea:	89 17       	cp	r24, r25
 3ec:	28 f4       	brcc	.+10     	; 0x3f8 <Isb_Inf_Usart_Tx+0x32>
						Free_Space = Inf_Usart_Tx0_Buffer_Tail - Inf_Usart_Tx0_Buffer_Head;
 3ee:	20 91 41 01 	lds	r18, 0x0141
 3f2:	80 91 42 01 	lds	r24, 0x0142
 3f6:	05 c0       	rjmp	.+10     	; 0x402 <Isb_Inf_Usart_Tx+0x3c>
					}
					else {
						Free_Space = (Inf_Usart_Tx0_Buffer_Tail + INF_USART_TX0_BUFFER_SIZE - Inf_Usart_Tx0_Buffer_Head);
 3f8:	20 91 41 01 	lds	r18, 0x0141
 3fc:	80 91 42 01 	lds	r24, 0x0142
 400:	20 5c       	subi	r18, 0xC0	; 192
 402:	28 1b       	sub	r18, r24
					}
					sei();
 404:	78 94       	sei
 406:	41 e0       	ldi	r20, 0x01	; 1
 408:	7d e0       	ldi	r23, 0x0D	; 13
 40a:	f7 2e       	mov	r15, r23
					Startbyte = ISB_INF_USART1_STARTBYTE;
					Stopbyte = ISB_INF_USART1_STOPBYTE;
					break;
			#endif /* INF_USART1_TX */
		}
		uint8_t aIsb_Msg_Dlc = aIsb_Msg->Flags & 0x0F;
 40c:	68 81       	ld	r22, Y
 40e:	6f 70       	andi	r22, 0x0F	; 15
		if (Free_Space > (9 + aIsb_Msg_Dlc)) {
 410:	06 2f       	mov	r16, r22
 412:	10 e0       	ldi	r17, 0x00	; 0
 414:	30 e0       	ldi	r19, 0x00	; 0
 416:	c8 01       	movw	r24, r16
 418:	09 96       	adiw	r24, 0x09	; 9
 41a:	82 17       	cp	r24, r18
 41c:	93 07       	cpc	r25, r19
 41e:	14 f0       	brlt	.+4      	; 0x424 <Isb_Inf_Usart_Tx+0x5e>
 420:	80 e0       	ldi	r24, 0x00	; 0
 422:	f9 c0       	rjmp	.+498    	; 0x616 <Isb_Inf_Usart_Tx+0x250>

	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 424:	55 23       	and	r21, r21
 426:	49 f5       	brne	.+82     	; 0x47a <Isb_Inf_Usart_Tx+0xb4>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 428:	90 91 42 01 	lds	r25, 0x0142
 42c:	9f 5f       	subi	r25, 0xFF	; 255
 42e:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 430:	80 91 41 01 	lds	r24, 0x0141
 434:	98 17       	cp	r25, r24
 436:	61 f0       	breq	.+24     	; 0x450 <Isb_Inf_Usart_Tx+0x8a>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 438:	e9 2f       	mov	r30, r25
 43a:	f0 e0       	ldi	r31, 0x00	; 0
 43c:	ed 57       	subi	r30, 0x7D	; 125
 43e:	fe 4f       	sbci	r31, 0xFE	; 254
 440:	40 83       	st	Z, r20
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 442:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 446:	80 91 c1 00 	lds	r24, 0x00C1
 44a:	80 62       	ori	r24, 0x20	; 32
 44c:	80 93 c1 00 	sts	0x00C1, r24
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 450:	90 91 42 01 	lds	r25, 0x0142
 454:	9f 5f       	subi	r25, 0xFF	; 255
 456:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 458:	80 91 41 01 	lds	r24, 0x0141
 45c:	98 17       	cp	r25, r24
 45e:	69 f0       	breq	.+26     	; 0x47a <Isb_Inf_Usart_Tx+0xb4>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 460:	e9 2f       	mov	r30, r25
 462:	f0 e0       	ldi	r31, 0x00	; 0
 464:	88 81       	ld	r24, Y
 466:	ed 57       	subi	r30, 0x7D	; 125
 468:	fe 4f       	sbci	r31, 0xFE	; 254
 46a:	80 83       	st	Z, r24
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 46c:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 470:	80 91 c1 00 	lds	r24, 0x00C1
 474:	80 62       	ori	r24, 0x20	; 32
 476:	80 93 c1 00 	sts	0x00C1, r24
			uint8_t aChar;
			aChar = Startbyte;
			Inf_Usart_Tx(aInf, &aChar);
			Inf_Usart_Tx(aInf, &aIsb_Msg->Flags);
			aChar = (uint8_t)aIsb_Msg->DestId;
 47a:	29 81       	ldd	r18, Y+1	; 0x01

	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 47c:	55 23       	and	r21, r21
 47e:	a1 f4       	brne	.+40     	; 0x4a8 <Isb_Inf_Usart_Tx+0xe2>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 480:	90 91 42 01 	lds	r25, 0x0142
 484:	9f 5f       	subi	r25, 0xFF	; 255
 486:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 488:	80 91 41 01 	lds	r24, 0x0141
 48c:	98 17       	cp	r25, r24
 48e:	61 f0       	breq	.+24     	; 0x4a8 <Isb_Inf_Usart_Tx+0xe2>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 490:	e9 2f       	mov	r30, r25
 492:	f0 e0       	ldi	r31, 0x00	; 0
 494:	ed 57       	subi	r30, 0x7D	; 125
 496:	fe 4f       	sbci	r31, 0xFE	; 254
 498:	20 83       	st	Z, r18
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 49a:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 49e:	80 91 c1 00 	lds	r24, 0x00C1
 4a2:	80 62       	ori	r24, 0x20	; 32
 4a4:	80 93 c1 00 	sts	0x00C1, r24
			Inf_Usart_Tx(aInf, &aChar);
			aChar = (uint8_t)(aIsb_Msg->DestId >> 8);
 4a8:	2a 81       	ldd	r18, Y+2	; 0x02

	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 4aa:	55 23       	and	r21, r21
 4ac:	a1 f4       	brne	.+40     	; 0x4d6 <Isb_Inf_Usart_Tx+0x110>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 4ae:	90 91 42 01 	lds	r25, 0x0142
 4b2:	9f 5f       	subi	r25, 0xFF	; 255
 4b4:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 4b6:	80 91 41 01 	lds	r24, 0x0141
 4ba:	98 17       	cp	r25, r24
 4bc:	61 f0       	breq	.+24     	; 0x4d6 <Isb_Inf_Usart_Tx+0x110>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 4be:	e9 2f       	mov	r30, r25
 4c0:	f0 e0       	ldi	r31, 0x00	; 0
 4c2:	ed 57       	subi	r30, 0x7D	; 125
 4c4:	fe 4f       	sbci	r31, 0xFE	; 254
 4c6:	20 83       	st	Z, r18
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 4c8:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 4cc:	80 91 c1 00 	lds	r24, 0x00C1
 4d0:	80 62       	ori	r24, 0x20	; 32
 4d2:	80 93 c1 00 	sts	0x00C1, r24
			Inf_Usart_Tx(aInf, &aChar);
			aChar = (uint8_t)aIsb_Msg->SourceId;
 4d6:	2b 81       	ldd	r18, Y+3	; 0x03

	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 4d8:	55 23       	and	r21, r21
 4da:	a1 f4       	brne	.+40     	; 0x504 <Isb_Inf_Usart_Tx+0x13e>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 4dc:	90 91 42 01 	lds	r25, 0x0142
 4e0:	9f 5f       	subi	r25, 0xFF	; 255
 4e2:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 4e4:	80 91 41 01 	lds	r24, 0x0141
 4e8:	98 17       	cp	r25, r24
 4ea:	61 f0       	breq	.+24     	; 0x504 <Isb_Inf_Usart_Tx+0x13e>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 4ec:	e9 2f       	mov	r30, r25
 4ee:	f0 e0       	ldi	r31, 0x00	; 0
 4f0:	ed 57       	subi	r30, 0x7D	; 125
 4f2:	fe 4f       	sbci	r31, 0xFE	; 254
 4f4:	20 83       	st	Z, r18
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 4f6:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 4fa:	80 91 c1 00 	lds	r24, 0x00C1
 4fe:	80 62       	ori	r24, 0x20	; 32
 500:	80 93 c1 00 	sts	0x00C1, r24
			Inf_Usart_Tx(aInf, &aChar);
			aChar = (uint8_t)(aIsb_Msg->SourceId >> 8);
 504:	2c 81       	ldd	r18, Y+4	; 0x04

	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 506:	55 23       	and	r21, r21
 508:	a1 f4       	brne	.+40     	; 0x532 <Isb_Inf_Usart_Tx+0x16c>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 50a:	90 91 42 01 	lds	r25, 0x0142
 50e:	9f 5f       	subi	r25, 0xFF	; 255
 510:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 512:	80 91 41 01 	lds	r24, 0x0141
 516:	98 17       	cp	r25, r24
 518:	61 f0       	breq	.+24     	; 0x532 <Isb_Inf_Usart_Tx+0x16c>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 51a:	e9 2f       	mov	r30, r25
 51c:	f0 e0       	ldi	r31, 0x00	; 0
 51e:	ed 57       	subi	r30, 0x7D	; 125
 520:	fe 4f       	sbci	r31, 0xFE	; 254
 522:	20 83       	st	Z, r18
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 524:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 528:	80 91 c1 00 	lds	r24, 0x00C1
 52c:	80 62       	ori	r24, 0x20	; 32
 52e:	80 93 c1 00 	sts	0x00C1, r24
 532:	20 e0       	ldi	r18, 0x00	; 0
 534:	1c c0       	rjmp	.+56     	; 0x56e <Isb_Inf_Usart_Tx+0x1a8>

	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 536:	55 23       	and	r21, r21
 538:	c9 f4       	brne	.+50     	; 0x56c <Isb_Inf_Usart_Tx+0x1a6>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 53a:	90 91 42 01 	lds	r25, 0x0142
 53e:	9f 5f       	subi	r25, 0xFF	; 255
 540:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 542:	80 91 41 01 	lds	r24, 0x0141
 546:	98 17       	cp	r25, r24
 548:	89 f0       	breq	.+34     	; 0x56c <Isb_Inf_Usart_Tx+0x1a6>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 54a:	e9 2f       	mov	r30, r25
 54c:	f0 e0       	ldi	r31, 0x00	; 0
 54e:	de 01       	movw	r26, r28
 550:	a2 0f       	add	r26, r18
 552:	b1 1d       	adc	r27, r1
 554:	15 96       	adiw	r26, 0x05	; 5
 556:	8c 91       	ld	r24, X
 558:	ed 57       	subi	r30, 0x7D	; 125
 55a:	fe 4f       	sbci	r31, 0xFE	; 254
 55c:	80 83       	st	Z, r24
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 55e:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 562:	80 91 c1 00 	lds	r24, 0x00C1
 566:	80 62       	ori	r24, 0x20	; 32
 568:	80 93 c1 00 	sts	0x00C1, r24
			Inf_Usart_Tx(aInf, &aChar);
			for (uint8_t i = 0; i < aIsb_Msg_Dlc; i++) {
 56c:	2f 5f       	subi	r18, 0xFF	; 255
 56e:	26 17       	cp	r18, r22
 570:	10 f3       	brcs	.-60     	; 0x536 <Isb_Inf_Usart_Tx+0x170>

	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 572:	55 23       	and	r21, r21
 574:	a1 f4       	brne	.+40     	; 0x59e <Isb_Inf_Usart_Tx+0x1d8>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 576:	90 91 42 01 	lds	r25, 0x0142
 57a:	9f 5f       	subi	r25, 0xFF	; 255
 57c:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 57e:	80 91 41 01 	lds	r24, 0x0141
 582:	98 17       	cp	r25, r24
 584:	61 f0       	breq	.+24     	; 0x59e <Isb_Inf_Usart_Tx+0x1d8>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 586:	e9 2f       	mov	r30, r25
 588:	f0 e0       	ldi	r31, 0x00	; 0
 58a:	ed 57       	subi	r30, 0x7D	; 125
 58c:	fe 4f       	sbci	r31, 0xFE	; 254
 58e:	10 82       	st	Z, r1
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 590:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 594:	80 91 c1 00 	lds	r24, 0x00C1
 598:	80 62       	ori	r24, 0x20	; 32
 59a:	80 93 c1 00 	sts	0x00C1, r24
				Inf_Usart_Tx(aInf, &aIsb_Msg->Data[i]);
			}
			aChar = 0x00;
			Inf_Usart_Tx(aInf, &aChar);
			aChar = Lib_Crc_Calc8(aIsb_Msg, (5 + aIsb_Msg_Dlc));
 59e:	b8 01       	movw	r22, r16
 5a0:	6b 5f       	subi	r22, 0xFB	; 251
 5a2:	7f 4f       	sbci	r23, 0xFF	; 255


	uint8_t Lib_Crc_Calc8(const void * aData, uint16_t aLength) {
		uint8_t Sum = 0;
		for (uint16_t i = 0; i < aLength; i++) {
			Sum += *(uint8_t *)(aData + i);
 5a4:	20 e0       	ldi	r18, 0x00	; 0
 5a6:	30 e0       	ldi	r19, 0x00	; 0
 5a8:	40 e0       	ldi	r20, 0x00	; 0
 5aa:	fe 01       	movw	r30, r28
 5ac:	e2 0f       	add	r30, r18
 5ae:	f3 1f       	adc	r31, r19
 5b0:	80 81       	ld	r24, Z
 5b2:	48 0f       	add	r20, r24



	uint8_t Lib_Crc_Calc8(const void * aData, uint16_t aLength) {
		uint8_t Sum = 0;
		for (uint16_t i = 0; i < aLength; i++) {
 5b4:	2f 5f       	subi	r18, 0xFF	; 255
 5b6:	3f 4f       	sbci	r19, 0xFF	; 255
 5b8:	26 17       	cp	r18, r22
 5ba:	37 07       	cpc	r19, r23
 5bc:	b0 f3       	brcs	.-20     	; 0x5aa <Isb_Inf_Usart_Tx+0x1e4>

	#if defined(INF_USART0_TX) || defined(INF_USART1_TX)
		uint8_t Inf_Usart_Tx(const uint8_t aInf, const uint8_t * aChar) {
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
 5be:	55 23       	and	r21, r21
 5c0:	49 f5       	brne	.+82     	; 0x614 <Isb_Inf_Usart_Tx+0x24e>
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 5c2:	90 91 42 01 	lds	r25, 0x0142
 5c6:	9f 5f       	subi	r25, 0xFF	; 255
 5c8:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 5ca:	80 91 41 01 	lds	r24, 0x0141
 5ce:	98 17       	cp	r25, r24
 5d0:	69 f0       	breq	.+26     	; 0x5ec <Isb_Inf_Usart_Tx+0x226>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 5d2:	e9 2f       	mov	r30, r25
 5d4:	f0 e0       	ldi	r31, 0x00	; 0
			Sum += *(uint8_t *)(aData + i);
		}
		return (uint8_t)((Sum ^ 0xFF) + 1);
 5d6:	41 95       	neg	r20
 5d8:	ed 57       	subi	r30, 0x7D	; 125
 5da:	fe 4f       	sbci	r31, 0xFE	; 254
 5dc:	40 83       	st	Z, r20
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 5de:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 5e2:	80 91 c1 00 	lds	r24, 0x00C1
 5e6:	80 62       	ori	r24, 0x20	; 32
 5e8:	80 93 c1 00 	sts	0x00C1, r24
			uint8_t Result = FALSE;
			uint8_t Tmp_Head;
			switch (aInf) {
				#if defined(INF_USART0_TX)
					case 0:
						Tmp_Head = (Inf_Usart_Tx0_Buffer_Head + 1) & INF_USART_TX0_BUFFER_MASK;
 5ec:	90 91 42 01 	lds	r25, 0x0142
 5f0:	9f 5f       	subi	r25, 0xFF	; 255
 5f2:	9f 73       	andi	r25, 0x3F	; 63
						if (Tmp_Head != Inf_Usart_Tx0_Buffer_Tail) {
 5f4:	80 91 41 01 	lds	r24, 0x0141
 5f8:	98 17       	cp	r25, r24
 5fa:	61 f0       	breq	.+24     	; 0x614 <Isb_Inf_Usart_Tx+0x24e>
							Inf_Usart_Tx0_Buffer[Tmp_Head] = *aChar;
 5fc:	e9 2f       	mov	r30, r25
 5fe:	f0 e0       	ldi	r31, 0x00	; 0
 600:	ed 57       	subi	r30, 0x7D	; 125
 602:	fe 4f       	sbci	r31, 0xFE	; 254
 604:	f0 82       	st	Z, r15
							Inf_Usart_Tx0_Buffer_Head = Tmp_Head;
 606:	90 93 42 01 	sts	0x0142, r25
								Result = TRUE;
							#elif defined(__AVR_ATmega169P__)
								UCSR0B |= (1 << UDRIE0);
								Result = TRUE;
							#elif defined(__AVR_ATmega644__)
								UCSR0B |= (1 << UDRIE0);
 60a:	80 91 c1 00 	lds	r24, 0x00C1
 60e:	80 62       	ori	r24, 0x20	; 32
 610:	80 93 c1 00 	sts	0x00C1, r24
 614:	81 e0       	ldi	r24, 0x01	; 1
			aChar = Stopbyte;
			Inf_Usart_Tx(aInf, &aChar);
			Result = TRUE;
		}
		return Result;
	}
 616:	df 91       	pop	r29
 618:	cf 91       	pop	r28
 61a:	1f 91       	pop	r17
 61c:	0f 91       	pop	r16
 61e:	ff 90       	pop	r15
 620:	08 95       	ret

00000622 <Isb_Inf_Usart_Rx>:



	uint8_t Isb_Inf_Usart_Rx(const uint8_t aInf, Isb_Msg_t * aIsb_Msg) {
 622:	bf 92       	push	r11
 624:	cf 92       	push	r12
 626:	df 92       	push	r13
 628:	ef 92       	push	r14
 62a:	ff 92       	push	r15
 62c:	0f 93       	push	r16
 62e:	1f 93       	push	r17
 630:	cf 93       	push	r28
 632:	df 93       	push	r29
 634:	db 01       	movw	r26, r22
		static volatile uint8_t * Buffer;
		static volatile uint8_t * Head;
		static volatile uint8_t * Tail;
		uint8_t Startbyte = 0;
		uint8_t Stopbyte = 0;
		switch (aInf) {
 636:	88 23       	and	r24, r24
 638:	11 f0       	breq	.+4      	; 0x63e <Isb_Inf_Usart_Rx+0x1c>
 63a:	bb 24       	eor	r11, r11
 63c:	30 c1       	rjmp	.+608    	; 0x89e <Isb_Inf_Usart_Rx+0x27c>
			#if defined(INF_USART0_RX)
				case 0:
					Mask = INF_USART_RX0_BUFFER_MASK;
					Buffer = Inf_Usart_Rx0_Buffer;
 63e:	83 e4       	ldi	r24, 0x43	; 67
 640:	91 e0       	ldi	r25, 0x01	; 1
 642:	90 93 40 01 	sts	0x0140, r25
 646:	80 93 3f 01 	sts	0x013F, r24
					Head = &Inf_Usart_Rx0_Buffer_Head;
 64a:	89 e3       	ldi	r24, 0x39	; 57
 64c:	91 e0       	ldi	r25, 0x01	; 1
 64e:	90 93 3e 01 	sts	0x013E, r25
 652:	80 93 3d 01 	sts	0x013D, r24
					Tail = &Inf_Usart_Rx0_Buffer_Tail;
 656:	8a e3       	ldi	r24, 0x3A	; 58
 658:	91 e0       	ldi	r25, 0x01	; 1
 65a:	90 93 3c 01 	sts	0x013C, r25
 65e:	80 93 3b 01 	sts	0x013B, r24
		}
		uint8_t Tmp_Tail;
		uint8_t Rel_Pos = 0;
		uint8_t Start_Pos = 0;
		uint8_t Isb_Msg_Dlc = 0;
		Tmp_Tail = (*Tail + 1) & Mask;
 662:	70 91 3a 01 	lds	r23, 0x013A
 666:	7f 5f       	subi	r23, 0xFF	; 255
 668:	7f 73       	andi	r23, 0x3F	; 63
				}
			}
			else if (Rel_Pos == 1) {
				aIsb_Msg->Flags = Buffer[Tmp_Tail];
				Rel_Pos++;
				if (bit_is_clear (aIsb_Msg->Flags, 6)) {
 66a:	bb 24       	eor	r11, r11
 66c:	60 e0       	ldi	r22, 0x00	; 0
 66e:	00 e0       	ldi	r16, 0x00	; 0
 670:	10 e0       	ldi	r17, 0x00	; 0
 672:	09 c1       	rjmp	.+530    	; 0x886 <Isb_Inf_Usart_Rx+0x264>
		uint8_t Rel_Pos = 0;
		uint8_t Start_Pos = 0;
		uint8_t Isb_Msg_Dlc = 0;
		Tmp_Tail = (*Tail + 1) & Mask;
		while (Tmp_Tail != ((*Head + 1) & Mask)) {
			if (Rel_Pos == 0) {
 674:	66 23       	and	r22, r22
 676:	59 f4       	brne	.+22     	; 0x68e <Isb_Inf_Usart_Rx+0x6c>
				if (Buffer[Tmp_Tail] == Startbyte) {
 678:	ed 5b       	subi	r30, 0xBD	; 189
 67a:	fe 4f       	sbci	r31, 0xFE	; 254
 67c:	80 81       	ld	r24, Z
 67e:	81 30       	cpi	r24, 0x01	; 1
 680:	19 f4       	brne	.+6      	; 0x688 <Isb_Inf_Usart_Rx+0x66>
 682:	07 2f       	mov	r16, r23
 684:	61 e0       	ldi	r22, 0x01	; 1
 686:	fd c0       	rjmp	.+506    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
					Start_Pos = Tmp_Tail;
					Rel_Pos++;
				}
				else {
					*Tail = Tmp_Tail;
 688:	70 93 3a 01 	sts	0x013A, r23
 68c:	fa c0       	rjmp	.+500    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
					Rel_Pos = 0;
				}
			}
			else if (Rel_Pos == 1) {
 68e:	61 30       	cpi	r22, 0x01	; 1
 690:	59 f4       	brne	.+22     	; 0x6a8 <Isb_Inf_Usart_Rx+0x86>
				aIsb_Msg->Flags = Buffer[Tmp_Tail];
 692:	ed 5b       	subi	r30, 0xBD	; 189
 694:	fe 4f       	sbci	r31, 0xFE	; 254
 696:	90 81       	ld	r25, Z
 698:	9c 93       	st	X, r25
				Rel_Pos++;
				if (bit_is_clear (aIsb_Msg->Flags, 6)) {
 69a:	8c 91       	ld	r24, X
 69c:	86 fd       	sbrc	r24, 6
 69e:	02 c0       	rjmp	.+4      	; 0x6a4 <Isb_Inf_Usart_Rx+0x82>
					Isb_Msg_Dlc = aIsb_Msg->Flags & ISB_MSG_FLAGS_DLC_MASK;
 6a0:	19 2f       	mov	r17, r25
 6a2:	1f 70       	andi	r17, 0x0F	; 15
 6a4:	62 e0       	ldi	r22, 0x02	; 2
 6a6:	ed c0       	rjmp	.+474    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				}
			}
			else if (Rel_Pos == 2) {
 6a8:	62 30       	cpi	r22, 0x02	; 2
 6aa:	59 f4       	brne	.+22     	; 0x6c2 <Isb_Inf_Usart_Rx+0xa0>
				aIsb_Msg->DestId = (uint16_t)Buffer[Tmp_Tail];
 6ac:	ed 5b       	subi	r30, 0xBD	; 189
 6ae:	fe 4f       	sbci	r31, 0xFE	; 254
 6b0:	80 81       	ld	r24, Z
 6b2:	11 96       	adiw	r26, 0x01	; 1
 6b4:	8c 93       	st	X, r24
 6b6:	11 97       	sbiw	r26, 0x01	; 1
 6b8:	12 96       	adiw	r26, 0x02	; 2
 6ba:	1c 92       	st	X, r1
 6bc:	12 97       	sbiw	r26, 0x02	; 2
 6be:	63 e0       	ldi	r22, 0x03	; 3
 6c0:	e0 c0       	rjmp	.+448    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if (Rel_Pos == 3) {
 6c2:	63 30       	cpi	r22, 0x03	; 3
 6c4:	89 f4       	brne	.+34     	; 0x6e8 <Isb_Inf_Usart_Rx+0xc6>
				aIsb_Msg->DestId += (uint16_t)(Buffer[Tmp_Tail] << 8);
 6c6:	ed 5b       	subi	r30, 0xBD	; 189
 6c8:	fe 4f       	sbci	r31, 0xFE	; 254
 6ca:	80 81       	ld	r24, Z
 6cc:	f8 2e       	mov	r15, r24
 6ce:	ee 24       	eor	r14, r14
 6d0:	11 96       	adiw	r26, 0x01	; 1
 6d2:	8d 91       	ld	r24, X+
 6d4:	9c 91       	ld	r25, X
 6d6:	12 97       	sbiw	r26, 0x02	; 2
 6d8:	8e 0d       	add	r24, r14
 6da:	9f 1d       	adc	r25, r15
 6dc:	12 96       	adiw	r26, 0x02	; 2
 6de:	9c 93       	st	X, r25
 6e0:	8e 93       	st	-X, r24
 6e2:	11 97       	sbiw	r26, 0x01	; 1
 6e4:	64 e0       	ldi	r22, 0x04	; 4
 6e6:	cd c0       	rjmp	.+410    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if (Rel_Pos == 4) {
 6e8:	64 30       	cpi	r22, 0x04	; 4
 6ea:	59 f4       	brne	.+22     	; 0x702 <Isb_Inf_Usart_Rx+0xe0>
				aIsb_Msg->SourceId = (uint16_t)Buffer[Tmp_Tail];
 6ec:	ed 5b       	subi	r30, 0xBD	; 189
 6ee:	fe 4f       	sbci	r31, 0xFE	; 254
 6f0:	80 81       	ld	r24, Z
 6f2:	13 96       	adiw	r26, 0x03	; 3
 6f4:	8c 93       	st	X, r24
 6f6:	13 97       	sbiw	r26, 0x03	; 3
 6f8:	14 96       	adiw	r26, 0x04	; 4
 6fa:	1c 92       	st	X, r1
 6fc:	14 97       	sbiw	r26, 0x04	; 4
 6fe:	65 e0       	ldi	r22, 0x05	; 5
 700:	c0 c0       	rjmp	.+384    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if (Rel_Pos == 5) {
 702:	65 30       	cpi	r22, 0x05	; 5
 704:	89 f4       	brne	.+34     	; 0x728 <Isb_Inf_Usart_Rx+0x106>
				aIsb_Msg->SourceId += (uint16_t)(Buffer[Tmp_Tail] << 8);
 706:	ed 5b       	subi	r30, 0xBD	; 189
 708:	fe 4f       	sbci	r31, 0xFE	; 254
 70a:	80 81       	ld	r24, Z
 70c:	d8 2e       	mov	r13, r24
 70e:	cc 24       	eor	r12, r12
 710:	13 96       	adiw	r26, 0x03	; 3
 712:	8d 91       	ld	r24, X+
 714:	9c 91       	ld	r25, X
 716:	14 97       	sbiw	r26, 0x04	; 4
 718:	8c 0d       	add	r24, r12
 71a:	9d 1d       	adc	r25, r13
 71c:	14 96       	adiw	r26, 0x04	; 4
 71e:	9c 93       	st	X, r25
 720:	8e 93       	st	-X, r24
 722:	13 97       	sbiw	r26, 0x03	; 3
 724:	66 e0       	ldi	r22, 0x06	; 6
 726:	ad c0       	rjmp	.+346    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if ((Rel_Pos == 6) & (Isb_Msg_Dlc >= 1)) {
 728:	66 30       	cpi	r22, 0x06	; 6
 72a:	59 f4       	brne	.+22     	; 0x742 <Isb_Inf_Usart_Rx+0x120>
 72c:	11 23       	and	r17, r17
 72e:	09 f4       	brne	.+2      	; 0x732 <Isb_Inf_Usart_Rx+0x110>
 730:	6d c0       	rjmp	.+218    	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
				aIsb_Msg->Data[0] = Buffer[Tmp_Tail];
 732:	ed 5b       	subi	r30, 0xBD	; 189
 734:	fe 4f       	sbci	r31, 0xFE	; 254
 736:	80 81       	ld	r24, Z
 738:	15 96       	adiw	r26, 0x05	; 5
 73a:	8c 93       	st	X, r24
 73c:	15 97       	sbiw	r26, 0x05	; 5
 73e:	67 e0       	ldi	r22, 0x07	; 7
 740:	a0 c0       	rjmp	.+320    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if ((Rel_Pos == 7) & (Isb_Msg_Dlc >= 2)) {
 742:	67 30       	cpi	r22, 0x07	; 7
 744:	69 f4       	brne	.+26     	; 0x760 <Isb_Inf_Usart_Rx+0x13e>
 746:	12 30       	cpi	r17, 0x02	; 2
 748:	08 f4       	brcc	.+2      	; 0x74c <Isb_Inf_Usart_Rx+0x12a>
 74a:	60 c0       	rjmp	.+192    	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
				aIsb_Msg->Data[1] = Buffer[Tmp_Tail];
 74c:	e7 2f       	mov	r30, r23
 74e:	f0 e0       	ldi	r31, 0x00	; 0
 750:	ed 5b       	subi	r30, 0xBD	; 189
 752:	fe 4f       	sbci	r31, 0xFE	; 254
 754:	80 81       	ld	r24, Z
 756:	16 96       	adiw	r26, 0x06	; 6
 758:	8c 93       	st	X, r24
 75a:	16 97       	sbiw	r26, 0x06	; 6
 75c:	68 e0       	ldi	r22, 0x08	; 8
 75e:	91 c0       	rjmp	.+290    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if ((Rel_Pos == 8) & (Isb_Msg_Dlc >= 3)) {
 760:	68 30       	cpi	r22, 0x08	; 8
 762:	69 f4       	brne	.+26     	; 0x77e <Isb_Inf_Usart_Rx+0x15c>
 764:	13 30       	cpi	r17, 0x03	; 3
 766:	08 f4       	brcc	.+2      	; 0x76a <Isb_Inf_Usart_Rx+0x148>
 768:	51 c0       	rjmp	.+162    	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
				aIsb_Msg->Data[2] = Buffer[Tmp_Tail];
 76a:	e7 2f       	mov	r30, r23
 76c:	f0 e0       	ldi	r31, 0x00	; 0
 76e:	ed 5b       	subi	r30, 0xBD	; 189
 770:	fe 4f       	sbci	r31, 0xFE	; 254
 772:	80 81       	ld	r24, Z
 774:	17 96       	adiw	r26, 0x07	; 7
 776:	8c 93       	st	X, r24
 778:	17 97       	sbiw	r26, 0x07	; 7
 77a:	69 e0       	ldi	r22, 0x09	; 9
 77c:	82 c0       	rjmp	.+260    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if ((Rel_Pos == 9) & (Isb_Msg_Dlc >= 4)) {
 77e:	69 30       	cpi	r22, 0x09	; 9
 780:	69 f4       	brne	.+26     	; 0x79c <Isb_Inf_Usart_Rx+0x17a>
 782:	14 30       	cpi	r17, 0x04	; 4
 784:	08 f4       	brcc	.+2      	; 0x788 <Isb_Inf_Usart_Rx+0x166>
 786:	42 c0       	rjmp	.+132    	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
				aIsb_Msg->Data[3] = Buffer[Tmp_Tail];
 788:	e7 2f       	mov	r30, r23
 78a:	f0 e0       	ldi	r31, 0x00	; 0
 78c:	ed 5b       	subi	r30, 0xBD	; 189
 78e:	fe 4f       	sbci	r31, 0xFE	; 254
 790:	80 81       	ld	r24, Z
 792:	18 96       	adiw	r26, 0x08	; 8
 794:	8c 93       	st	X, r24
 796:	18 97       	sbiw	r26, 0x08	; 8
 798:	6a e0       	ldi	r22, 0x0A	; 10
 79a:	73 c0       	rjmp	.+230    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if ((Rel_Pos == 10) & (Isb_Msg_Dlc >= 5)) {
 79c:	6a 30       	cpi	r22, 0x0A	; 10
 79e:	61 f4       	brne	.+24     	; 0x7b8 <Isb_Inf_Usart_Rx+0x196>
 7a0:	15 30       	cpi	r17, 0x05	; 5
 7a2:	a0 f1       	brcs	.+104    	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
				aIsb_Msg->Data[4] = Buffer[Tmp_Tail];
 7a4:	e7 2f       	mov	r30, r23
 7a6:	f0 e0       	ldi	r31, 0x00	; 0
 7a8:	ed 5b       	subi	r30, 0xBD	; 189
 7aa:	fe 4f       	sbci	r31, 0xFE	; 254
 7ac:	80 81       	ld	r24, Z
 7ae:	19 96       	adiw	r26, 0x09	; 9
 7b0:	8c 93       	st	X, r24
 7b2:	19 97       	sbiw	r26, 0x09	; 9
 7b4:	6b e0       	ldi	r22, 0x0B	; 11
 7b6:	65 c0       	rjmp	.+202    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if ((Rel_Pos == 11) & (Isb_Msg_Dlc >= 6)) {
 7b8:	6b 30       	cpi	r22, 0x0B	; 11
 7ba:	61 f4       	brne	.+24     	; 0x7d4 <Isb_Inf_Usart_Rx+0x1b2>
 7bc:	16 30       	cpi	r17, 0x06	; 6
 7be:	30 f1       	brcs	.+76     	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
				aIsb_Msg->Data[5] = Buffer[Tmp_Tail];
 7c0:	e7 2f       	mov	r30, r23
 7c2:	f0 e0       	ldi	r31, 0x00	; 0
 7c4:	ed 5b       	subi	r30, 0xBD	; 189
 7c6:	fe 4f       	sbci	r31, 0xFE	; 254
 7c8:	80 81       	ld	r24, Z
 7ca:	1a 96       	adiw	r26, 0x0a	; 10
 7cc:	8c 93       	st	X, r24
 7ce:	1a 97       	sbiw	r26, 0x0a	; 10
 7d0:	6c e0       	ldi	r22, 0x0C	; 12
 7d2:	57 c0       	rjmp	.+174    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if ((Rel_Pos == 12) & (Isb_Msg_Dlc >= 7)) {
 7d4:	6c 30       	cpi	r22, 0x0C	; 12
 7d6:	61 f4       	brne	.+24     	; 0x7f0 <Isb_Inf_Usart_Rx+0x1ce>
 7d8:	17 30       	cpi	r17, 0x07	; 7
 7da:	c0 f0       	brcs	.+48     	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
				aIsb_Msg->Data[6] = Buffer[Tmp_Tail];
 7dc:	e7 2f       	mov	r30, r23
 7de:	f0 e0       	ldi	r31, 0x00	; 0
 7e0:	ed 5b       	subi	r30, 0xBD	; 189
 7e2:	fe 4f       	sbci	r31, 0xFE	; 254
 7e4:	80 81       	ld	r24, Z
 7e6:	1b 96       	adiw	r26, 0x0b	; 11
 7e8:	8c 93       	st	X, r24
 7ea:	1b 97       	sbiw	r26, 0x0b	; 11
 7ec:	6d e0       	ldi	r22, 0x0D	; 13
 7ee:	49 c0       	rjmp	.+146    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if ((Rel_Pos == 13) & (Isb_Msg_Dlc == 8)) {
 7f0:	6d 30       	cpi	r22, 0x0D	; 13
 7f2:	61 f4       	brne	.+24     	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
 7f4:	18 30       	cpi	r17, 0x08	; 8
 7f6:	51 f4       	brne	.+20     	; 0x80c <Isb_Inf_Usart_Rx+0x1ea>
				aIsb_Msg->Data[7] = Buffer[Tmp_Tail];
 7f8:	e7 2f       	mov	r30, r23
 7fa:	f0 e0       	ldi	r31, 0x00	; 0
 7fc:	ed 5b       	subi	r30, 0xBD	; 189
 7fe:	fe 4f       	sbci	r31, 0xFE	; 254
 800:	80 81       	ld	r24, Z
 802:	1c 96       	adiw	r26, 0x0c	; 12
 804:	8c 93       	st	X, r24
 806:	1c 97       	sbiw	r26, 0x0c	; 12
 808:	6e e0       	ldi	r22, 0x0E	; 14
 80a:	3b c0       	rjmp	.+118    	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				Rel_Pos++;
			}
			else if (Rel_Pos == (6 + Isb_Msg_Dlc)) {
 80c:	46 2f       	mov	r20, r22
 80e:	50 e0       	ldi	r21, 0x00	; 0
 810:	21 2f       	mov	r18, r17
 812:	30 e0       	ldi	r19, 0x00	; 0
 814:	c9 01       	movw	r24, r18
 816:	06 96       	adiw	r24, 0x06	; 6
 818:	48 17       	cp	r20, r24
 81a:	59 07       	cpc	r21, r25
 81c:	e1 f0       	breq	.+56     	; 0x856 <Isb_Inf_Usart_Rx+0x234>
				Rel_Pos++;
			}
			else if (Rel_Pos == (7 + Isb_Msg_Dlc)) {
 81e:	c9 01       	movw	r24, r18
 820:	07 96       	adiw	r24, 0x07	; 7
 822:	48 17       	cp	r20, r24
 824:	59 07       	cpc	r21, r25
 826:	c9 f4       	brne	.+50     	; 0x85a <Isb_Inf_Usart_Rx+0x238>
				if (Buffer[Tmp_Tail] == Lib_Crc_Calc8(aIsb_Msg, (5 + Isb_Msg_Dlc))) {
 828:	e7 2f       	mov	r30, r23
 82a:	f0 e0       	ldi	r31, 0x00	; 0
 82c:	ed 5b       	subi	r30, 0xBD	; 189
 82e:	fe 4f       	sbci	r31, 0xFE	; 254
 830:	90 81       	ld	r25, Z
 832:	e9 01       	movw	r28, r18
 834:	25 96       	adiw	r28, 0x05	; 5
 836:	20 e0       	ldi	r18, 0x00	; 0
 838:	30 e0       	ldi	r19, 0x00	; 0
 83a:	40 e0       	ldi	r20, 0x00	; 0


	uint8_t Lib_Crc_Calc8(const void * aData, uint16_t aLength) {
		uint8_t Sum = 0;
		for (uint16_t i = 0; i < aLength; i++) {
			Sum += *(uint8_t *)(aData + i);
 83c:	fd 01       	movw	r30, r26
 83e:	e2 0f       	add	r30, r18
 840:	f3 1f       	adc	r31, r19
 842:	80 81       	ld	r24, Z
 844:	48 0f       	add	r20, r24



	uint8_t Lib_Crc_Calc8(const void * aData, uint16_t aLength) {
		uint8_t Sum = 0;
		for (uint16_t i = 0; i < aLength; i++) {
 846:	2f 5f       	subi	r18, 0xFF	; 255
 848:	3f 4f       	sbci	r19, 0xFF	; 255
 84a:	2c 17       	cp	r18, r28
 84c:	3d 07       	cpc	r19, r29
 84e:	b0 f3       	brcs	.-20     	; 0x83c <Isb_Inf_Usart_Rx+0x21a>
 850:	41 95       	neg	r20
 852:	94 17       	cp	r25, r20
 854:	71 f4       	brne	.+28     	; 0x872 <Isb_Inf_Usart_Rx+0x250>
					Rel_Pos++;
 856:	6f 5f       	subi	r22, 0xFF	; 255
 858:	14 c0       	rjmp	.+40     	; 0x882 <Isb_Inf_Usart_Rx+0x260>
					*Tail = Start_Pos;
					Rel_Pos = 0;
					continue;
				}
			}
			else if (Rel_Pos == (8 + Isb_Msg_Dlc)) {
 85a:	28 5f       	subi	r18, 0xF8	; 248
 85c:	3f 4f       	sbci	r19, 0xFF	; 255
 85e:	42 17       	cp	r20, r18
 860:	53 07       	cpc	r21, r19
 862:	79 f4       	brne	.+30     	; 0x882 <Isb_Inf_Usart_Rx+0x260>
				if (Buffer[Tmp_Tail] != Stopbyte) {
 864:	e7 2f       	mov	r30, r23
 866:	f0 e0       	ldi	r31, 0x00	; 0
 868:	ed 5b       	subi	r30, 0xBD	; 189
 86a:	fe 4f       	sbci	r31, 0xFE	; 254
 86c:	80 81       	ld	r24, Z
 86e:	8d 30       	cpi	r24, 0x0D	; 13
 870:	21 f0       	breq	.+8      	; 0x87a <Isb_Inf_Usart_Rx+0x258>
					*Tail = Start_Pos;
 872:	00 93 3a 01 	sts	0x013A, r16
 876:	60 e0       	ldi	r22, 0x00	; 0
 878:	06 c0       	rjmp	.+12     	; 0x886 <Isb_Inf_Usart_Rx+0x264>
					Rel_Pos = 0;
					continue;
				}
				else {
					*Tail = Tmp_Tail;
 87a:	70 93 3a 01 	sts	0x013A, r23
 87e:	bb 24       	eor	r11, r11
 880:	b3 94       	inc	r11
					Result = TRUE;
				}
			}
			Tmp_Tail = (Tmp_Tail + 1) & Mask;
 882:	7f 5f       	subi	r23, 0xFF	; 255
 884:	7f 73       	andi	r23, 0x3F	; 63
		uint8_t Tmp_Tail;
		uint8_t Rel_Pos = 0;
		uint8_t Start_Pos = 0;
		uint8_t Isb_Msg_Dlc = 0;
		Tmp_Tail = (*Tail + 1) & Mask;
		while (Tmp_Tail != ((*Head + 1) & Mask)) {
 886:	80 91 39 01 	lds	r24, 0x0139
 88a:	e7 2f       	mov	r30, r23
 88c:	f0 e0       	ldi	r31, 0x00	; 0
 88e:	90 e0       	ldi	r25, 0x00	; 0
 890:	01 96       	adiw	r24, 0x01	; 1
 892:	8f 73       	andi	r24, 0x3F	; 63
 894:	90 70       	andi	r25, 0x00	; 0
 896:	e8 17       	cp	r30, r24
 898:	f9 07       	cpc	r31, r25
 89a:	09 f0       	breq	.+2      	; 0x89e <Isb_Inf_Usart_Rx+0x27c>
 89c:	eb ce       	rjmp	.-554    	; 0x674 <Isb_Inf_Usart_Rx+0x52>
				}
			}
			Tmp_Tail = (Tmp_Tail + 1) & Mask;
		}
		return Result;
	}
 89e:	8b 2d       	mov	r24, r11
 8a0:	df 91       	pop	r29
 8a2:	cf 91       	pop	r28
 8a4:	1f 91       	pop	r17
 8a6:	0f 91       	pop	r16
 8a8:	ff 90       	pop	r15
 8aa:	ef 90       	pop	r14
 8ac:	df 90       	pop	r13
 8ae:	cf 90       	pop	r12
 8b0:	bf 90       	pop	r11
 8b2:	08 95       	ret

000008b4 <Node_Reboot>:
	#include "./../lib/isb_config.h"
	#include "./../lib/isb_config.c"



	void Node_Reboot(void) {
 8b4:	ff cf       	rjmp	.-2      	; 0x8b4 <Node_Reboot>

000008b6 <Isb_SendMsg>:
		while (1) ;
	}



	void Isb_SendMsg(Isb_Msg_t * aMsg) {
 8b6:	bc 01       	movw	r22, r24
		#if ISB_INF_USART0 == 1
			Isb_Inf_Usart_Tx(0, aMsg);
 8b8:	80 e0       	ldi	r24, 0x00	; 0
 8ba:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <Isb_Inf_Usart_Tx>
		#endif /* ISB_INF_CAN2 == 1 */
//		if ((aMsg->Flags & ISB_MSG_FLAGS_TOF_MASK) == ISB_MSG_FLAGS_TOF_MULTICAST) {
//			if (Error == 0) {
//			}
//		}
	}
 8be:	08 95       	ret

000008c0 <Isb_Config_Rx>:
#ifndef ISB_SRV_CONFIG_C_
	#define ISB_SRV_CONFIG_C_



	void Isb_Config_Rx(Isb_Msg_t * aIsb_Msg) {
 8c0:	cf 92       	push	r12
 8c2:	df 92       	push	r13
 8c4:	ef 92       	push	r14
 8c6:	ff 92       	push	r15
 8c8:	0f 93       	push	r16
 8ca:	1f 93       	push	r17
 8cc:	df 93       	push	r29
 8ce:	cf 93       	push	r28
 8d0:	cd b7       	in	r28, 0x3d	; 61
 8d2:	de b7       	in	r29, 0x3e	; 62
 8d4:	2d 97       	sbiw	r28, 0x0d	; 13
 8d6:	0f b6       	in	r0, 0x3f	; 63
 8d8:	f8 94       	cli
 8da:	de bf       	out	0x3e, r29	; 62
 8dc:	0f be       	out	0x3f, r0	; 63
 8de:	cd bf       	out	0x3d, r28	; 61
 8e0:	ac 01       	movw	r20, r24
		uint8_t Dlc;
		Isb_Msg_t MsgTx;
		uint16_t Addr;
		Dlc = aIsb_Msg->Flags & ISB_MSG_FLAGS_DLC_MASK;
 8e2:	fc 01       	movw	r30, r24
 8e4:	00 81       	ld	r16, Z
 8e6:	10 2f       	mov	r17, r16
 8e8:	1f 70       	andi	r17, 0x0F	; 15
		MsgTx.Flags = aIsb_Msg->Flags;
		MsgTx.DestId = aIsb_Msg->SourceId;
 8ea:	c3 80       	ldd	r12, Z+3	; 0x03
 8ec:	d4 80       	ldd	r13, Z+4	; 0x04
		MsgTx.SourceId = Isb_Node_Id;
 8ee:	e0 90 34 01 	lds	r14, 0x0134
 8f2:	f0 90 35 01 	lds	r15, 0x0135
 8f6:	dc 01       	movw	r26, r24
 8f8:	fe 01       	movw	r30, r28
 8fa:	36 96       	adiw	r30, 0x06	; 6
		for (uint8_t i = 0; i < Dlc; i++) {
 8fc:	9e 01       	movw	r18, r28
 8fe:	21 0f       	add	r18, r17
 900:	31 1d       	adc	r19, r1
 902:	2a 5f       	subi	r18, 0xFA	; 250
 904:	3f 4f       	sbci	r19, 0xFF	; 255
 906:	04 c0       	rjmp	.+8      	; 0x910 <Isb_Config_Rx+0x50>
			MsgTx.Data[i] = aIsb_Msg->Data[i];
 908:	14 96       	adiw	r26, 0x04	; 4
 90a:	8c 91       	ld	r24, X
 90c:	14 97       	sbiw	r26, 0x04	; 4
 90e:	81 93       	st	Z+, r24
 910:	11 96       	adiw	r26, 0x01	; 1
		uint16_t Addr;
		Dlc = aIsb_Msg->Flags & ISB_MSG_FLAGS_DLC_MASK;
		MsgTx.Flags = aIsb_Msg->Flags;
		MsgTx.DestId = aIsb_Msg->SourceId;
		MsgTx.SourceId = Isb_Node_Id;
		for (uint8_t i = 0; i < Dlc; i++) {
 912:	e2 17       	cp	r30, r18
 914:	f3 07       	cpc	r31, r19
 916:	c1 f7       	brne	.-16     	; 0x908 <Isb_Config_Rx+0x48>
			MsgTx.Data[i] = aIsb_Msg->Data[i];
		}
		if (aIsb_Msg->Data[0] == ISB_CONFIG_CMD_SETMODE) {
 918:	fa 01       	movw	r30, r20
 91a:	85 81       	ldd	r24, Z+5	; 0x05
 91c:	82 30       	cpi	r24, 0x02	; 2
 91e:	09 f0       	breq	.+2      	; 0x922 <Isb_Config_Rx+0x62>
 920:	95 c0       	rjmp	.+298    	; 0xa4c <Isb_Config_Rx+0x18c>
			if (Dlc == ISB_MSG_FLAGS_DLC_2) {
 922:	12 30       	cpi	r17, 0x02	; 2
 924:	09 f0       	breq	.+2      	; 0x928 <Isb_Config_Rx+0x68>
 926:	4d c1       	rjmp	.+666    	; 0xbc2 <Isb_Config_Rx+0x302>
				MsgTx.Flags = ISB_MSG_FLAGS_TOF_UNICAST | ISB_MSG_FLAGS_DLC_2;
				MsgTx.Data[0] |= ISB_CONFIG_ANSWER_ACK;
 928:	8e 81       	ldd	r24, Y+6	; 0x06
 92a:	80 6c       	ori	r24, 0xC0	; 192
 92c:	8e 83       	std	Y+6, r24	; 0x06
				if (aIsb_Msg->Data[1] == ISB_NODE_OPERATING_MODE__BL_NORM) {
 92e:	26 81       	ldd	r18, Z+6	; 0x06
 930:	22 23       	and	r18, r18
 932:	c9 f4       	brne	.+50     	; 0x966 <Isb_Config_Rx+0xa6>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 934:	f9 99       	sbic	0x1f, 1	; 31
 936:	fe cf       	rjmp	.-4      	; 0x934 <Isb_Config_Rx+0x74>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 938:	82 e1       	ldi	r24, 0x12	; 18
 93a:	90 e0       	ldi	r25, 0x00	; 0
 93c:	92 bd       	out	0x22, r25	; 34
 93e:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 940:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 942:	80 b5       	in	r24, 0x20	; 32
	}



	void __attribute__((always_inline)) lib_eep_write_byte(uint8_t * aAddr, uint8_t aData) {
		if (eeprom_read_byte(aAddr) != aData) {
 944:	88 23       	and	r24, r24
 946:	09 f4       	brne	.+2      	; 0x94a <Isb_Config_Rx+0x8a>
 948:	66 c0       	rjmp	.+204    	; 0xa16 <Isb_Config_Rx+0x156>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 94a:	f9 99       	sbic	0x1f, 1	; 31
 94c:	fe cf       	rjmp	.-4      	; 0x94a <Isb_Config_Rx+0x8a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 94e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 950:	82 e1       	ldi	r24, 0x12	; 18
 952:	90 e0       	ldi	r25, 0x00	; 0
 954:	92 bd       	out	0x22, r25	; 34
 956:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
 958:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
 95a:	0f b6       	in	r0, 0x3f	; 63
 95c:	f8 94       	cli
 95e:	fa 9a       	sbi	0x1f, 2	; 31
 960:	f9 9a       	sbi	0x1f, 1	; 31
 962:	0f be       	out	0x3f, r0	; 63
 964:	72 c0       	rjmp	.+228    	; 0xa4a <Isb_Config_Rx+0x18a>
					lib_eep_write_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE, ISB_NODE_OPERATING_MODE__BL_NORM);
				}
				if (aIsb_Msg->Data[1] == ISB_NODE_OPERATING_MODE__BL_FLASH) {
 966:	21 30       	cpi	r18, 0x01	; 1
 968:	d1 f4       	brne	.+52     	; 0x99e <Isb_Config_Rx+0xde>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 96a:	f9 99       	sbic	0x1f, 1	; 31
 96c:	fe cf       	rjmp	.-4      	; 0x96a <Isb_Config_Rx+0xaa>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 96e:	82 e1       	ldi	r24, 0x12	; 18
 970:	90 e0       	ldi	r25, 0x00	; 0
 972:	92 bd       	out	0x22, r25	; 34
 974:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 976:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 978:	80 b5       	in	r24, 0x20	; 32
 97a:	81 30       	cpi	r24, 0x01	; 1
 97c:	09 f4       	brne	.+2      	; 0x980 <Isb_Config_Rx+0xc0>
 97e:	65 c0       	rjmp	.+202    	; 0xa4a <Isb_Config_Rx+0x18a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 980:	f9 99       	sbic	0x1f, 1	; 31
 982:	fe cf       	rjmp	.-4      	; 0x980 <Isb_Config_Rx+0xc0>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 984:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 986:	82 e1       	ldi	r24, 0x12	; 18
 988:	90 e0       	ldi	r25, 0x00	; 0
 98a:	92 bd       	out	0x22, r25	; 34
 98c:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
 98e:	81 e0       	ldi	r24, 0x01	; 1
 990:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
 992:	0f b6       	in	r0, 0x3f	; 63
 994:	f8 94       	cli
 996:	fa 9a       	sbi	0x1f, 2	; 31
 998:	f9 9a       	sbi	0x1f, 1	; 31
 99a:	0f be       	out	0x3f, r0	; 63
 99c:	56 c0       	rjmp	.+172    	; 0xa4a <Isb_Config_Rx+0x18a>
					lib_eep_write_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE, ISB_NODE_OPERATING_MODE__BL_FLASH);
				}
				if (aIsb_Msg->Data[1] == ISB_NODE_OPERATING_MODE__FW_NORM) {
 99e:	28 30       	cpi	r18, 0x08	; 8
 9a0:	09 f0       	breq	.+2      	; 0x9a4 <Isb_Config_Rx+0xe4>
 9a2:	39 c0       	rjmp	.+114    	; 0xa16 <Isb_Config_Rx+0x156>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 9a4:	f9 99       	sbic	0x1f, 1	; 31
 9a6:	fe cf       	rjmp	.-4      	; 0x9a4 <Isb_Config_Rx+0xe4>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 9a8:	8b e1       	ldi	r24, 0x1B	; 27
 9aa:	90 e0       	ldi	r25, 0x00	; 0
 9ac:	92 bd       	out	0x22, r25	; 34
 9ae:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 9b0:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 9b2:	20 b5       	in	r18, 0x20	; 32
					uint8_t crc = lib_eep_read_byte((uint8_t *)EEP__ISB_CONFIG_CRC);
					crc++;
 9b4:	2f 5f       	subi	r18, 0xFF	; 255
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 9b6:	f9 99       	sbic	0x1f, 1	; 31
 9b8:	fe cf       	rjmp	.-4      	; 0x9b6 <Isb_Config_Rx+0xf6>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 9ba:	8b e1       	ldi	r24, 0x1B	; 27
 9bc:	90 e0       	ldi	r25, 0x00	; 0
 9be:	92 bd       	out	0x22, r25	; 34
 9c0:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 9c2:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 9c4:	80 b5       	in	r24, 0x20	; 32
 9c6:	82 17       	cp	r24, r18
 9c8:	69 f0       	breq	.+26     	; 0x9e4 <Isb_Config_Rx+0x124>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 9ca:	f9 99       	sbic	0x1f, 1	; 31
 9cc:	fe cf       	rjmp	.-4      	; 0x9ca <Isb_Config_Rx+0x10a>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 9ce:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 9d0:	8b e1       	ldi	r24, 0x1B	; 27
 9d2:	90 e0       	ldi	r25, 0x00	; 0
 9d4:	92 bd       	out	0x22, r25	; 34
 9d6:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
 9d8:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
 9da:	0f b6       	in	r0, 0x3f	; 63
 9dc:	f8 94       	cli
 9de:	fa 9a       	sbi	0x1f, 2	; 31
 9e0:	f9 9a       	sbi	0x1f, 1	; 31
 9e2:	0f be       	out	0x3f, r0	; 63
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 9e4:	f9 99       	sbic	0x1f, 1	; 31
 9e6:	fe cf       	rjmp	.-4      	; 0x9e4 <Isb_Config_Rx+0x124>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 9e8:	82 e1       	ldi	r24, 0x12	; 18
 9ea:	90 e0       	ldi	r25, 0x00	; 0
 9ec:	92 bd       	out	0x22, r25	; 34
 9ee:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 9f0:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 9f2:	80 b5       	in	r24, 0x20	; 32
 9f4:	88 30       	cpi	r24, 0x08	; 8
 9f6:	49 f1       	breq	.+82     	; 0xa4a <Isb_Config_Rx+0x18a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 9f8:	f9 99       	sbic	0x1f, 1	; 31
 9fa:	fe cf       	rjmp	.-4      	; 0x9f8 <Isb_Config_Rx+0x138>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 9fc:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 9fe:	82 e1       	ldi	r24, 0x12	; 18
 a00:	90 e0       	ldi	r25, 0x00	; 0
 a02:	92 bd       	out	0x22, r25	; 34
 a04:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
 a06:	88 e0       	ldi	r24, 0x08	; 8
 a08:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
 a0a:	0f b6       	in	r0, 0x3f	; 63
 a0c:	f8 94       	cli
 a0e:	fa 9a       	sbi	0x1f, 2	; 31
 a10:	f9 9a       	sbi	0x1f, 1	; 31
 a12:	0f be       	out	0x3f, r0	; 63
 a14:	1a c0       	rjmp	.+52     	; 0xa4a <Isb_Config_Rx+0x18a>
					lib_eep_write_byte((uint8_t *)EEP__ISB_CONFIG_CRC, crc);
					lib_eep_write_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE, ISB_NODE_OPERATING_MODE__FW_NORM);
				}
				if (aIsb_Msg->Data[1] == ISB_NODE_OPERATING_MODE__FW_CFG) {
 a16:	29 30       	cpi	r18, 0x09	; 9
 a18:	c1 f4       	brne	.+48     	; 0xa4a <Isb_Config_Rx+0x18a>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 a1a:	f9 99       	sbic	0x1f, 1	; 31
 a1c:	fe cf       	rjmp	.-4      	; 0xa1a <Isb_Config_Rx+0x15a>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 a1e:	82 e1       	ldi	r24, 0x12	; 18
 a20:	90 e0       	ldi	r25, 0x00	; 0
 a22:	92 bd       	out	0x22, r25	; 34
 a24:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 a26:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 a28:	80 b5       	in	r24, 0x20	; 32
 a2a:	89 30       	cpi	r24, 0x09	; 9
 a2c:	71 f0       	breq	.+28     	; 0xa4a <Isb_Config_Rx+0x18a>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 a2e:	f9 99       	sbic	0x1f, 1	; 31
 a30:	fe cf       	rjmp	.-4      	; 0xa2e <Isb_Config_Rx+0x16e>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 a32:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 a34:	82 e1       	ldi	r24, 0x12	; 18
 a36:	90 e0       	ldi	r25, 0x00	; 0
 a38:	92 bd       	out	0x22, r25	; 34
 a3a:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
 a3c:	89 e0       	ldi	r24, 0x09	; 9
 a3e:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
 a40:	0f b6       	in	r0, 0x3f	; 63
 a42:	f8 94       	cli
 a44:	fa 9a       	sbi	0x1f, 2	; 31
 a46:	f9 9a       	sbi	0x1f, 1	; 31
 a48:	0f be       	out	0x3f, r0	; 63
 a4a:	ff cf       	rjmp	.-2      	; 0xa4a <Isb_Config_Rx+0x18a>
					lib_eep_write_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE, ISB_NODE_OPERATING_MODE__FW_CFG);
				}
				Node_Reboot();
			}
		}
		else if (aIsb_Msg->Data[0] == ISB_CONFIG_CMD_INITEEPROM) {
 a4c:	86 30       	cpi	r24, 0x06	; 6
 a4e:	09 f0       	breq	.+2      	; 0xa52 <Isb_Config_Rx+0x192>
 a50:	45 c0       	rjmp	.+138    	; 0xadc <Isb_Config_Rx+0x21c>
			if (Dlc == ISB_MSG_FLAGS_DLC_1) {
 a52:	11 30       	cpi	r17, 0x01	; 1
 a54:	09 f0       	breq	.+2      	; 0xa58 <Isb_Config_Rx+0x198>
 a56:	b5 c0       	rjmp	.+362    	; 0xbc2 <Isb_Config_Rx+0x302>
				if (Isb_Node_Operating_Mode == ISB_NODE_OPERATING_MODE__FW_CFG) {
 a58:	80 91 37 01 	lds	r24, 0x0137
 a5c:	89 30       	cpi	r24, 0x09	; 9
 a5e:	09 f0       	breq	.+2      	; 0xa62 <Isb_Config_Rx+0x1a2>
 a60:	b0 c0       	rjmp	.+352    	; 0xbc2 <Isb_Config_Rx+0x302>
					MsgTx.Flags = ISB_MSG_FLAGS_TOF_UNICAST | ISB_MSG_FLAGS_DLC_1;
					MsgTx.Data[0] |= ISB_CONFIG_ANSWER_ACK;
					for (uint16_t ee_Addr = Isb_Firmware_Offset; ee_Addr < EEP_SIZE; ee_Addr++) {
 a62:	80 91 36 01 	lds	r24, 0x0136
 a66:	28 2f       	mov	r18, r24
 a68:	30 e0       	ldi	r19, 0x00	; 0
						wdt_reset();
 a6a:	a8 95       	wdr
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 a6c:	f9 99       	sbic	0x1f, 1	; 31
 a6e:	fe cf       	rjmp	.-4      	; 0xa6c <Isb_Config_Rx+0x1ac>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 a70:	32 bd       	out	0x22, r19	; 34
 a72:	21 bd       	out	0x21, r18	; 33
#endif
    EECR |= (1 << EERE);
 a74:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 a76:	80 b5       	in	r24, 0x20	; 32
 a78:	88 23       	and	r24, r24
 a7a:	59 f0       	breq	.+22     	; 0xa92 <Isb_Config_Rx+0x1d2>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 a7c:	f9 99       	sbic	0x1f, 1	; 31
 a7e:	fe cf       	rjmp	.-4      	; 0xa7c <Isb_Config_Rx+0x1bc>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 a80:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 a82:	32 bd       	out	0x22, r19	; 34
 a84:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
 a86:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
 a88:	0f b6       	in	r0, 0x3f	; 63
 a8a:	f8 94       	cli
 a8c:	fa 9a       	sbi	0x1f, 2	; 31
 a8e:	f9 9a       	sbi	0x1f, 1	; 31
 a90:	0f be       	out	0x3f, r0	; 63
		else if (aIsb_Msg->Data[0] == ISB_CONFIG_CMD_INITEEPROM) {
			if (Dlc == ISB_MSG_FLAGS_DLC_1) {
				if (Isb_Node_Operating_Mode == ISB_NODE_OPERATING_MODE__FW_CFG) {
					MsgTx.Flags = ISB_MSG_FLAGS_TOF_UNICAST | ISB_MSG_FLAGS_DLC_1;
					MsgTx.Data[0] |= ISB_CONFIG_ANSWER_ACK;
					for (uint16_t ee_Addr = Isb_Firmware_Offset; ee_Addr < EEP_SIZE; ee_Addr++) {
 a92:	2f 5f       	subi	r18, 0xFF	; 255
 a94:	3f 4f       	sbci	r19, 0xFF	; 255
 a96:	f8 e0       	ldi	r31, 0x08	; 8
 a98:	20 30       	cpi	r18, 0x00	; 0
 a9a:	3f 07       	cpc	r19, r31
 a9c:	30 f3       	brcs	.-52     	; 0xa6a <Isb_Config_Rx+0x1aa>
 a9e:	2c e1       	ldi	r18, 0x1C	; 28
 aa0:	30 e0       	ldi	r19, 0x00	; 0
						wdt_reset();
						lib_eep_write_byte((uint8_t *) ee_Addr, 0x00);
					}
					for (uint8_t i = 0; i < 4; i++) {
						lib_eep_write_byte((uint8_t *)(EEP__ISB_CONFIG_CODE_0 + i), Isb_Firmware_Code[i]);
 aa2:	f9 01       	movw	r30, r18
 aa4:	ec 51       	subi	r30, 0x1C	; 28
 aa6:	ff 4f       	sbci	r31, 0xFF	; 255
 aa8:	e0 81       	ld	r30, Z
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 aaa:	f9 99       	sbic	0x1f, 1	; 31
 aac:	fe cf       	rjmp	.-4      	; 0xaaa <Isb_Config_Rx+0x1ea>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 aae:	32 bd       	out	0x22, r19	; 34
 ab0:	21 bd       	out	0x21, r18	; 33
#endif
    EECR |= (1 << EERE);
 ab2:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 ab4:	80 b5       	in	r24, 0x20	; 32
 ab6:	8e 17       	cp	r24, r30
 ab8:	59 f0       	breq	.+22     	; 0xad0 <Isb_Config_Rx+0x210>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 aba:	f9 99       	sbic	0x1f, 1	; 31
 abc:	fe cf       	rjmp	.-4      	; 0xaba <Isb_Config_Rx+0x1fa>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 abe:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 ac0:	32 bd       	out	0x22, r19	; 34
 ac2:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
 ac4:	e0 bd       	out	0x20, r30	; 32

    __asm__ __volatile__ (
 ac6:	0f b6       	in	r0, 0x3f	; 63
 ac8:	f8 94       	cli
 aca:	fa 9a       	sbi	0x1f, 2	; 31
 acc:	f9 9a       	sbi	0x1f, 1	; 31
 ace:	0f be       	out	0x3f, r0	; 63
 ad0:	2f 5f       	subi	r18, 0xFF	; 255
 ad2:	3f 4f       	sbci	r19, 0xFF	; 255
					MsgTx.Data[0] |= ISB_CONFIG_ANSWER_ACK;
					for (uint16_t ee_Addr = Isb_Firmware_Offset; ee_Addr < EEP_SIZE; ee_Addr++) {
						wdt_reset();
						lib_eep_write_byte((uint8_t *) ee_Addr, 0x00);
					}
					for (uint8_t i = 0; i < 4; i++) {
 ad4:	20 32       	cpi	r18, 0x20	; 32
 ad6:	31 05       	cpc	r19, r1
 ad8:	21 f7       	brne	.-56     	; 0xaa2 <Isb_Config_Rx+0x1e2>
 ada:	ff cf       	rjmp	.-2      	; 0xada <Isb_Config_Rx+0x21a>
					}
					Node_Reboot();
				}
			}
		}
		else if (aIsb_Msg->Data[0] == ISB_CONFIG_CMD_READEEPROMBLOCK) {
 adc:	87 30       	cpi	r24, 0x07	; 7
 ade:	69 f5       	brne	.+90     	; 0xb3a <Isb_Config_Rx+0x27a>
			if (Dlc > ISB_MSG_FLAGS_DLC_3) {
 ae0:	14 30       	cpi	r17, 0x04	; 4
 ae2:	08 f4       	brcc	.+2      	; 0xae6 <Isb_Config_Rx+0x226>
 ae4:	6e c0       	rjmp	.+220    	; 0xbc2 <Isb_Config_Rx+0x302>
				Addr = (uint16_t)aIsb_Msg->Data[1] + (uint16_t)(aIsb_Msg->Data[2] << 8);
 ae6:	fa 01       	movw	r30, r20
 ae8:	97 81       	ldd	r25, Z+7	; 0x07
 aea:	80 e0       	ldi	r24, 0x00	; 0
 aec:	26 81       	ldd	r18, Z+6	; 0x06
 aee:	bc 01       	movw	r22, r24
 af0:	62 0f       	add	r22, r18
 af2:	71 1d       	adc	r23, r1
				if (Addr < EEP_SIZE) {
 af4:	f8 e0       	ldi	r31, 0x08	; 8
 af6:	60 30       	cpi	r22, 0x00	; 0
 af8:	7f 07       	cpc	r23, r31
 afa:	08 f0       	brcs	.+2      	; 0xafe <Isb_Config_Rx+0x23e>
 afc:	62 c0       	rjmp	.+196    	; 0xbc2 <Isb_Config_Rx+0x302>
					MsgTx.Data[0] |= ISB_CONFIG_ANSWER_ACK;
 afe:	8e 81       	ldd	r24, Y+6	; 0x06
 b00:	80 6c       	ori	r24, 0xC0	; 192
 b02:	8e 83       	std	Y+6, r24	; 0x06
 b04:	40 e0       	ldi	r20, 0x00	; 0
					for (uint8_t i = 0; i < (Dlc - 3); i++) {
 b06:	21 2f       	mov	r18, r17
 b08:	30 e0       	ldi	r19, 0x00	; 0
 b0a:	23 50       	subi	r18, 0x03	; 3
 b0c:	30 40       	sbci	r19, 0x00	; 0
						MsgTx.Data[3 + i] = lib_eep_read_byte((uint8_t *)(Addr + i));
 b0e:	de 01       	movw	r26, r28
 b10:	19 96       	adiw	r26, 0x09	; 9
 b12:	0d c0       	rjmp	.+26     	; 0xb2e <Isb_Config_Rx+0x26e>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 b14:	f9 99       	sbic	0x1f, 1	; 31
 b16:	fe cf       	rjmp	.-4      	; 0xb14 <Isb_Config_Rx+0x254>
 b18:	cb 01       	movw	r24, r22
 b1a:	84 0f       	add	r24, r20
 b1c:	91 1d       	adc	r25, r1
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 b1e:	92 bd       	out	0x22, r25	; 34
 b20:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 b22:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 b24:	80 b5       	in	r24, 0x20	; 32
 b26:	ea 0f       	add	r30, r26
 b28:	fb 1f       	adc	r31, r27
 b2a:	80 83       	st	Z, r24
		else if (aIsb_Msg->Data[0] == ISB_CONFIG_CMD_READEEPROMBLOCK) {
			if (Dlc > ISB_MSG_FLAGS_DLC_3) {
				Addr = (uint16_t)aIsb_Msg->Data[1] + (uint16_t)(aIsb_Msg->Data[2] << 8);
				if (Addr < EEP_SIZE) {
					MsgTx.Data[0] |= ISB_CONFIG_ANSWER_ACK;
					for (uint8_t i = 0; i < (Dlc - 3); i++) {
 b2c:	4f 5f       	subi	r20, 0xFF	; 255
 b2e:	e4 2f       	mov	r30, r20
 b30:	f0 e0       	ldi	r31, 0x00	; 0
 b32:	e2 17       	cp	r30, r18
 b34:	f3 07       	cpc	r31, r19
 b36:	74 f3       	brlt	.-36     	; 0xb14 <Isb_Config_Rx+0x254>
 b38:	44 c0       	rjmp	.+136    	; 0xbc2 <Isb_Config_Rx+0x302>
						MsgTx.Data[3 + i] = lib_eep_read_byte((uint8_t *)(Addr + i));
					}
				}
			}
		}
		else if (aIsb_Msg->Data[0] == ISB_CONFIG_CMD_WRITEEEPROMBLOCK) {
 b3a:	88 30       	cpi	r24, 0x08	; 8
 b3c:	09 f0       	breq	.+2      	; 0xb40 <Isb_Config_Rx+0x280>
 b3e:	41 c0       	rjmp	.+130    	; 0xbc2 <Isb_Config_Rx+0x302>
			if (Dlc > ISB_MSG_FLAGS_DLC_3) {
 b40:	14 30       	cpi	r17, 0x04	; 4
 b42:	08 f4       	brcc	.+2      	; 0xb46 <Isb_Config_Rx+0x286>
 b44:	3e c0       	rjmp	.+124    	; 0xbc2 <Isb_Config_Rx+0x302>
				if (Isb_Node_Operating_Mode == ISB_NODE_OPERATING_MODE__FW_CFG) {
 b46:	80 91 37 01 	lds	r24, 0x0137
 b4a:	89 30       	cpi	r24, 0x09	; 9
 b4c:	09 f0       	breq	.+2      	; 0xb50 <Isb_Config_Rx+0x290>
 b4e:	39 c0       	rjmp	.+114    	; 0xbc2 <Isb_Config_Rx+0x302>
					Addr = (uint16_t)aIsb_Msg->Data[1] + (uint16_t)(aIsb_Msg->Data[2] << 8);
 b50:	fa 01       	movw	r30, r20
 b52:	97 81       	ldd	r25, Z+7	; 0x07
 b54:	80 e0       	ldi	r24, 0x00	; 0
 b56:	26 81       	ldd	r18, Z+6	; 0x06
 b58:	bc 01       	movw	r22, r24
 b5a:	62 0f       	add	r22, r18
 b5c:	71 1d       	adc	r23, r1
					if ((Addr >= Isb_Firmware_Offset) & (Addr < EEP_SIZE)) {
 b5e:	80 91 36 01 	lds	r24, 0x0136
 b62:	90 e0       	ldi	r25, 0x00	; 0
 b64:	68 17       	cp	r22, r24
 b66:	79 07       	cpc	r23, r25
 b68:	60 f1       	brcs	.+88     	; 0xbc2 <Isb_Config_Rx+0x302>
 b6a:	f8 e0       	ldi	r31, 0x08	; 8
 b6c:	60 30       	cpi	r22, 0x00	; 0
 b6e:	7f 07       	cpc	r23, r31
 b70:	40 f5       	brcc	.+80     	; 0xbc2 <Isb_Config_Rx+0x302>
						MsgTx.Data[0] |= ISB_CONFIG_ANSWER_ACK;
 b72:	8e 81       	ldd	r24, Y+6	; 0x06
 b74:	80 6c       	ori	r24, 0xC0	; 192
 b76:	8e 83       	std	Y+6, r24	; 0x06
 b78:	90 e0       	ldi	r25, 0x00	; 0
						for (uint8_t i = 0; i < (Dlc - 3); i++) {
 b7a:	21 2f       	mov	r18, r17
 b7c:	30 e0       	ldi	r19, 0x00	; 0
 b7e:	23 50       	subi	r18, 0x03	; 3
 b80:	30 40       	sbci	r19, 0x00	; 0
 b82:	1a c0       	rjmp	.+52     	; 0xbb8 <Isb_Config_Rx+0x2f8>
							lib_eep_write_byte((uint8_t *)(Addr + i), aIsb_Msg->Data[3 + i]);
 b84:	df 01       	movw	r26, r30
 b86:	a6 0f       	add	r26, r22
 b88:	b7 1f       	adc	r27, r23
 b8a:	e4 0f       	add	r30, r20
 b8c:	f5 1f       	adc	r31, r21
 b8e:	e0 85       	ldd	r30, Z+8	; 0x08
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 b90:	f9 99       	sbic	0x1f, 1	; 31
 b92:	fe cf       	rjmp	.-4      	; 0xb90 <Isb_Config_Rx+0x2d0>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 b94:	b2 bd       	out	0x22, r27	; 34
 b96:	a1 bd       	out	0x21, r26	; 33
#endif
    EECR |= (1 << EERE);
 b98:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 b9a:	80 b5       	in	r24, 0x20	; 32
 b9c:	8e 17       	cp	r24, r30
 b9e:	59 f0       	breq	.+22     	; 0xbb6 <Isb_Config_Rx+0x2f6>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 ba0:	f9 99       	sbic	0x1f, 1	; 31
 ba2:	fe cf       	rjmp	.-4      	; 0xba0 <Isb_Config_Rx+0x2e0>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 ba4:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 ba6:	b2 bd       	out	0x22, r27	; 34
 ba8:	a1 bd       	out	0x21, r26	; 33
#endif
    EEDR = __value;
 baa:	e0 bd       	out	0x20, r30	; 32

    __asm__ __volatile__ (
 bac:	0f b6       	in	r0, 0x3f	; 63
 bae:	f8 94       	cli
 bb0:	fa 9a       	sbi	0x1f, 2	; 31
 bb2:	f9 9a       	sbi	0x1f, 1	; 31
 bb4:	0f be       	out	0x3f, r0	; 63
			if (Dlc > ISB_MSG_FLAGS_DLC_3) {
				if (Isb_Node_Operating_Mode == ISB_NODE_OPERATING_MODE__FW_CFG) {
					Addr = (uint16_t)aIsb_Msg->Data[1] + (uint16_t)(aIsb_Msg->Data[2] << 8);
					if ((Addr >= Isb_Firmware_Offset) & (Addr < EEP_SIZE)) {
						MsgTx.Data[0] |= ISB_CONFIG_ANSWER_ACK;
						for (uint8_t i = 0; i < (Dlc - 3); i++) {
 bb6:	9f 5f       	subi	r25, 0xFF	; 255
 bb8:	e9 2f       	mov	r30, r25
 bba:	f0 e0       	ldi	r31, 0x00	; 0
 bbc:	e2 17       	cp	r30, r18
 bbe:	f3 07       	cpc	r31, r19
 bc0:	0c f3       	brlt	.-62     	; 0xb84 <Isb_Config_Rx+0x2c4>
						}
					}
				}
			}
		}
		MsgTx.Data[0] |= ISB_CONFIG_ANSWER_NACK;
 bc2:	8e 81       	ldd	r24, Y+6	; 0x06
 bc4:	80 64       	ori	r24, 0x40	; 64
 bc6:	8e 83       	std	Y+6, r24	; 0x06
		Isb_Msg_t MsgTx;
		uint16_t Addr;
		Dlc = aIsb_Msg->Flags & ISB_MSG_FLAGS_DLC_MASK;
		MsgTx.Flags = aIsb_Msg->Flags;
		MsgTx.DestId = aIsb_Msg->SourceId;
		MsgTx.SourceId = Isb_Node_Id;
 bc8:	fd 82       	std	Y+5, r15	; 0x05
 bca:	ec 82       	std	Y+4, r14	; 0x04
		uint8_t Dlc;
		Isb_Msg_t MsgTx;
		uint16_t Addr;
		Dlc = aIsb_Msg->Flags & ISB_MSG_FLAGS_DLC_MASK;
		MsgTx.Flags = aIsb_Msg->Flags;
		MsgTx.DestId = aIsb_Msg->SourceId;
 bcc:	db 82       	std	Y+3, r13	; 0x03
 bce:	ca 82       	std	Y+2, r12	; 0x02
	void Isb_Config_Rx(Isb_Msg_t * aIsb_Msg) {
		uint8_t Dlc;
		Isb_Msg_t MsgTx;
		uint16_t Addr;
		Dlc = aIsb_Msg->Flags & ISB_MSG_FLAGS_DLC_MASK;
		MsgTx.Flags = aIsb_Msg->Flags;
 bd0:	09 83       	std	Y+1, r16	; 0x01
					}
				}
			}
		}
		MsgTx.Data[0] |= ISB_CONFIG_ANSWER_NACK;
		Isb_SendMsg(&MsgTx);
 bd2:	ce 01       	movw	r24, r28
 bd4:	01 96       	adiw	r24, 0x01	; 1
 bd6:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <Isb_SendMsg>
	}
 bda:	2d 96       	adiw	r28, 0x0d	; 13
 bdc:	0f b6       	in	r0, 0x3f	; 63
 bde:	f8 94       	cli
 be0:	de bf       	out	0x3e, r29	; 62
 be2:	0f be       	out	0x3f, r0	; 63
 be4:	cd bf       	out	0x3d, r28	; 61
 be6:	cf 91       	pop	r28
 be8:	df 91       	pop	r29
 bea:	1f 91       	pop	r17
 bec:	0f 91       	pop	r16
 bee:	ff 90       	pop	r15
 bf0:	ef 90       	pop	r14
 bf2:	df 90       	pop	r13
 bf4:	cf 90       	pop	r12
 bf6:	08 95       	ret

00000bf8 <lib_eep_fw_read_word>:
/** \ingroup avr_eeprom
    Read one 16-bit word (little endian) from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
{
    return __eerd_word (__p, eeprom_read_byte);
 bf8:	20 91 36 01 	lds	r18, 0x0136
 bfc:	30 e0       	ldi	r19, 0x00	; 0
 bfe:	22 0f       	add	r18, r18
 c00:	33 1f       	adc	r19, r19
 c02:	82 0f       	add	r24, r18
 c04:	93 1f       	adc	r25, r19
 c06:	67 e5       	ldi	r22, 0x57	; 87
 c08:	70 e0       	ldi	r23, 0x00	; 0
 c0a:	0e 94 10 07 	call	0xe20	; 0xe20 <__eerd_word>



	uint16_t __attribute__((always_inline)) lib_eep_fw_read_word(uint16_t * aAddr) {
		return eeprom_read_word(Isb_Firmware_Offset + aAddr);;
	}
 c0e:	08 95       	ret

00000c10 <lib_eep_read_word>:
 c10:	67 e5       	ldi	r22, 0x57	; 87
 c12:	70 e0       	ldi	r23, 0x00	; 0
 c14:	0e 94 10 07 	call	0xe20	; 0xe20 <__eerd_word>



	uint16_t __attribute__((always_inline)) lib_eep_read_word(uint16_t * aAddr) {
		return eeprom_read_word(aAddr);;
	}
 c18:	08 95       	ret

00000c1a <main>:



	int main(void) {
 c1a:	ff 92       	push	r15
 c1c:	0f 93       	push	r16
 c1e:	1f 93       	push	r17
 c20:	df 93       	push	r29
 c22:	cf 93       	push	r28
 c24:	cd b7       	in	r28, 0x3d	; 61
 c26:	de b7       	in	r29, 0x3e	; 62
 c28:	2d 97       	sbiw	r28, 0x0d	; 13
 c2a:	0f b6       	in	r0, 0x3f	; 63
 c2c:	f8 94       	cli
 c2e:	de bf       	out	0x3e, r29	; 62
 c30:	0f be       	out	0x3f, r0	; 63
 c32:	cd bf       	out	0x3d, r28	; 61
		wdt_enable(WDTO_500MS);
 c34:	8d e0       	ldi	r24, 0x0D	; 13
 c36:	28 e1       	ldi	r18, 0x18	; 24
 c38:	30 e0       	ldi	r19, 0x00	; 0
 c3a:	0f b6       	in	r0, 0x3f	; 63
 c3c:	f8 94       	cli
 c3e:	a8 95       	wdr
 c40:	20 93 60 00 	sts	0x0060, r18
 c44:	0f be       	out	0x3f, r0	; 63
 c46:	80 93 60 00 	sts	0x0060, r24
		wdt_reset();
 c4a:	a8 95       	wdr
 c4c:	80 e1       	ldi	r24, 0x10	; 16
 c4e:	90 e0       	ldi	r25, 0x00	; 0
 c50:	67 e5       	ldi	r22, 0x57	; 87
 c52:	70 e0       	ldi	r23, 0x00	; 0
 c54:	0e 94 10 07 	call	0xe20	; 0xe20 <__eerd_word>
 c58:	bc 01       	movw	r22, r24
		Isb_Node_Id = lib_eep_read_word((uint16_t *)EEP__ISB_NODE_ID_0);
 c5a:	90 93 35 01 	sts	0x0135, r25
 c5e:	80 93 34 01 	sts	0x0134, r24
		if ((Isb_Node_Id == 0) | (Isb_Node_Id > 2047)) {
 c62:	01 97       	sbiw	r24, 0x01	; 1
 c64:	8f 5f       	subi	r24, 0xFF	; 255
 c66:	97 40       	sbci	r25, 0x07	; 7
 c68:	c0 f0       	brcs	.+48     	; 0xc9a <main+0x80>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 c6a:	f9 99       	sbic	0x1f, 1	; 31
 c6c:	fe cf       	rjmp	.-4      	; 0xc6a <main+0x50>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 c6e:	82 e1       	ldi	r24, 0x12	; 18
 c70:	90 e0       	ldi	r25, 0x00	; 0
 c72:	92 bd       	out	0x22, r25	; 34
 c74:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 c76:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 c78:	80 b5       	in	r24, 0x20	; 32



	void __attribute__((always_inline)) lib_eep_write_byte(uint8_t * aAddr, uint8_t aData) {
		if (eeprom_read_byte(aAddr) != aData) {
 c7a:	88 23       	and	r24, r24
 c7c:	69 f0       	breq	.+26     	; 0xc98 <main+0x7e>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 c7e:	f9 99       	sbic	0x1f, 1	; 31
 c80:	fe cf       	rjmp	.-4      	; 0xc7e <main+0x64>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 c82:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 c84:	82 e1       	ldi	r24, 0x12	; 18
 c86:	90 e0       	ldi	r25, 0x00	; 0
 c88:	92 bd       	out	0x22, r25	; 34
 c8a:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
 c8c:	10 bc       	out	0x20, r1	; 32

    __asm__ __volatile__ (
 c8e:	0f b6       	in	r0, 0x3f	; 63
 c90:	f8 94       	cli
 c92:	fa 9a       	sbi	0x1f, 2	; 31
 c94:	f9 9a       	sbi	0x1f, 1	; 31
 c96:	0f be       	out	0x3f, r0	; 63
 c98:	ff cf       	rjmp	.-2      	; 0xc98 <main+0x7e>
 c9a:	2c e0       	ldi	r18, 0x0C	; 12
 c9c:	30 e0       	ldi	r19, 0x00	; 0
			lib_eep_write_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE, ISB_NODE_OPERATING_MODE__BL_NORM);
			Node_Reboot();
		}
		for (uint8_t i = 0; i < 4; i++) {
			lib_eep_write_byte((uint8_t *)(EEP__ISB_FIRMWARE_CODE_0 + i), Isb_Firmware_Code[i]);
 c9e:	f9 01       	movw	r30, r18
 ca0:	ec 50       	subi	r30, 0x0C	; 12
 ca2:	ff 4f       	sbci	r31, 0xFF	; 255
 ca4:	e0 81       	ld	r30, Z
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 ca6:	f9 99       	sbic	0x1f, 1	; 31
 ca8:	fe cf       	rjmp	.-4      	; 0xca6 <main+0x8c>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 caa:	32 bd       	out	0x22, r19	; 34
 cac:	21 bd       	out	0x21, r18	; 33
#endif
    EECR |= (1 << EERE);
 cae:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 cb0:	80 b5       	in	r24, 0x20	; 32
 cb2:	8e 17       	cp	r24, r30
 cb4:	59 f0       	breq	.+22     	; 0xccc <main+0xb2>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 cb6:	f9 99       	sbic	0x1f, 1	; 31
 cb8:	fe cf       	rjmp	.-4      	; 0xcb6 <main+0x9c>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 cba:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 cbc:	32 bd       	out	0x22, r19	; 34
 cbe:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
 cc0:	e0 bd       	out	0x20, r30	; 32

    __asm__ __volatile__ (
 cc2:	0f b6       	in	r0, 0x3f	; 63
 cc4:	f8 94       	cli
 cc6:	fa 9a       	sbi	0x1f, 2	; 31
 cc8:	f9 9a       	sbi	0x1f, 1	; 31
 cca:	0f be       	out	0x3f, r0	; 63
 ccc:	2f 5f       	subi	r18, 0xFF	; 255
 cce:	3f 4f       	sbci	r19, 0xFF	; 255
		Isb_Node_Id = lib_eep_read_word((uint16_t *)EEP__ISB_NODE_ID_0);
		if ((Isb_Node_Id == 0) | (Isb_Node_Id > 2047)) {
			lib_eep_write_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE, ISB_NODE_OPERATING_MODE__BL_NORM);
			Node_Reboot();
		}
		for (uint8_t i = 0; i < 4; i++) {
 cd0:	20 31       	cpi	r18, 0x10	; 16
 cd2:	31 05       	cpc	r19, r1
 cd4:	21 f7       	brne	.-56     	; 0xc9e <main+0x84>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 cd6:	f9 99       	sbic	0x1f, 1	; 31
 cd8:	fe cf       	rjmp	.-4      	; 0xcd6 <main+0xbc>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 cda:	8a e1       	ldi	r24, 0x1A	; 26
 cdc:	90 e0       	ldi	r25, 0x00	; 0
 cde:	92 bd       	out	0x22, r25	; 34
 ce0:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 ce2:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 ce4:	80 b5       	in	r24, 0x20	; 32
			lib_eep_write_byte((uint8_t *)(EEP__ISB_FIRMWARE_CODE_0 + i), Isb_Firmware_Code[i]);
		}
		Isb_Firmware_Offset = lib_eep_read_byte((uint8_t *)EEP__ISB_FIRMWARE_OFFSET);
 ce6:	80 93 36 01 	sts	0x0136, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 cea:	f9 99       	sbic	0x1f, 1	; 31
 cec:	fe cf       	rjmp	.-4      	; 0xcea <main+0xd0>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 cee:	82 e1       	ldi	r24, 0x12	; 18
 cf0:	90 e0       	ldi	r25, 0x00	; 0
 cf2:	92 bd       	out	0x22, r25	; 34
 cf4:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 cf6:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 cf8:	80 b5       	in	r24, 0x20	; 32
		Isb_Node_Operating_Mode = lib_eep_read_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE);
 cfa:	80 93 37 01 	sts	0x0137, r24
		if ((Isb_Node_Operating_Mode != ISB_NODE_OPERATING_MODE__FW_NORM) & (Isb_Node_Operating_Mode != ISB_NODE_OPERATING_MODE__FW_CFG))
 cfe:	88 50       	subi	r24, 0x08	; 8
 d00:	82 30       	cpi	r24, 0x02	; 2
 d02:	d8 f0       	brcs	.+54     	; 0xd3a <main+0x120>
		{
			Isb_Node_Operating_Mode = ISB_NODE_OPERATING_MODE__FW_NORM;
 d04:	88 e0       	ldi	r24, 0x08	; 8
 d06:	80 93 37 01 	sts	0x0137, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 d0a:	f9 99       	sbic	0x1f, 1	; 31
 d0c:	fe cf       	rjmp	.-4      	; 0xd0a <main+0xf0>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 d0e:	82 e1       	ldi	r24, 0x12	; 18
 d10:	90 e0       	ldi	r25, 0x00	; 0
 d12:	92 bd       	out	0x22, r25	; 34
 d14:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 d16:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 d18:	80 b5       	in	r24, 0x20	; 32
 d1a:	88 30       	cpi	r24, 0x08	; 8
 d1c:	71 f0       	breq	.+28     	; 0xd3a <main+0x120>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 d1e:	f9 99       	sbic	0x1f, 1	; 31
 d20:	fe cf       	rjmp	.-4      	; 0xd1e <main+0x104>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
 d22:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 d24:	82 e1       	ldi	r24, 0x12	; 18
 d26:	90 e0       	ldi	r25, 0x00	; 0
 d28:	92 bd       	out	0x22, r25	; 34
 d2a:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
 d2c:	88 e0       	ldi	r24, 0x08	; 8
 d2e:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
 d30:	0f b6       	in	r0, 0x3f	; 63
 d32:	f8 94       	cli
 d34:	fa 9a       	sbi	0x1f, 2	; 31
 d36:	f9 9a       	sbi	0x1f, 1	; 31
 d38:	0f be       	out	0x3f, r0	; 63
 d3a:	40 91 38 01 	lds	r20, 0x0138
 d3e:	2c e1       	ldi	r18, 0x1C	; 28
 d40:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 d42:	f9 99       	sbic	0x1f, 1	; 31
 d44:	fe cf       	rjmp	.-4      	; 0xd42 <main+0x128>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 d46:	32 bd       	out	0x22, r19	; 34
 d48:	21 bd       	out	0x21, r18	; 33
#endif
    EECR |= (1 << EERE);
 d4a:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 d4c:	80 b5       	in	r24, 0x20	; 32
			lib_eep_write_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE, Isb_Node_Operating_Mode);
		}
		for (uint8_t i = 0; i < 4; i++)
		{
			if (lib_eep_read_byte((uint8_t *)(EEP__ISB_CONFIG_CODE_0 + i)) != Isb_Firmware_Code[i])
 d4e:	f9 01       	movw	r30, r18
 d50:	ec 51       	subi	r30, 0x1C	; 28
 d52:	ff 4f       	sbci	r31, 0xFF	; 255
 d54:	90 81       	ld	r25, Z
 d56:	89 13       	cpse	r24, r25
			{
				Error |= ERROR__CONFIG_CODE;
 d58:	41 60       	ori	r20, 0x01	; 1
 d5a:	2f 5f       	subi	r18, 0xFF	; 255
 d5c:	3f 4f       	sbci	r19, 0xFF	; 255
		if ((Isb_Node_Operating_Mode != ISB_NODE_OPERATING_MODE__FW_NORM) & (Isb_Node_Operating_Mode != ISB_NODE_OPERATING_MODE__FW_CFG))
		{
			Isb_Node_Operating_Mode = ISB_NODE_OPERATING_MODE__FW_NORM;
			lib_eep_write_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE, Isb_Node_Operating_Mode);
		}
		for (uint8_t i = 0; i < 4; i++)
 d5e:	20 32       	cpi	r18, 0x20	; 32
 d60:	31 05       	cpc	r19, r1
 d62:	79 f7       	brne	.-34     	; 0xd42 <main+0x128>
 d64:	40 93 38 01 	sts	0x0138, r20
			if (lib_eep_read_byte((uint8_t *)(EEP__ISB_CONFIG_CODE_0 + i)) != Isb_Firmware_Code[i])
			{
				Error |= ERROR__CONFIG_CODE;
			}
		}
		sei();
 d68:	78 94       	sei
			uint8_t Result = FALSE;
			switch (aInf) {
				#if defined(INF_USART0_RX) || defined(INF_USART0_TX)
					case 0:
						#if defined(INF_USART0_RX)
							Inf_Usart_Rx0_Buffer_Tail = Inf_Usart_Rx0_Buffer_Head;
 d6a:	80 91 39 01 	lds	r24, 0x0139
 d6e:	80 93 3a 01 	sts	0x013A, r24
						#endif /* INF_USART0_RX */
						#if defined(INF_USART0_TX)
							Inf_Usart_Tx0_Buffer_Tail = Inf_Usart_Tx0_Buffer_Head;
 d72:	80 91 42 01 	lds	r24, 0x0142
 d76:	80 93 41 01 	sts	0x0141, r24
							UBRR0L = aUbrrl;
							UCSR0C = aUcsrc;
							UCSR0B = aUcsrb;
							Result = TRUE;
						#elif defined(__AVR_ATmega644__)
							UCSR0A = aUcsra;
 d7a:	83 e0       	ldi	r24, 0x03	; 3
 d7c:	80 93 c0 00 	sts	0x00C0, r24
							UBRR0H = aUbrrh;
 d80:	10 92 c5 00 	sts	0x00C5, r1
							UBRR0L = aUbrrl;
 d84:	80 e1       	ldi	r24, 0x10	; 16
 d86:	80 93 c4 00 	sts	0x00C4, r24
							UCSR0C = aUcsrc;
 d8a:	86 e0       	ldi	r24, 0x06	; 6
 d8c:	80 93 c2 00 	sts	0x00C2, r24
							UCSR0B = aUcsrb;
 d90:	88 eb       	ldi	r24, 0xB8	; 184
 d92:	80 93 c1 00 	sts	0x00C1, r24
		#endif /* ISB_INF_CAN2 == 1 */
		Isb_Msg_t Isb_Msg;
		Isb_Msg.Flags = ISB_MSG_FLAGS_TOF_MULTICAST | ISB_MSG_FLAGS_DLC_7;
		Isb_Msg.DestId = ISB_MSG_MULTICAST_GROUPID_FW_START;
		Isb_Msg.SourceId = Isb_Node_Id;
		Isb_Msg.Data[0] = ISB_MSG_TOP__SERIAL_NUMBER__MODE__ERROR;
 d96:	81 e2       	ldi	r24, 0x21	; 33
 d98:	8e 83       	std	Y+6, r24	; 0x06
 d9a:	fe 01       	movw	r30, r28
 d9c:	37 96       	adiw	r30, 0x07	; 7
 d9e:	24 e0       	ldi	r18, 0x04	; 4
 da0:	30 e0       	ldi	r19, 0x00	; 0
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 da2:	f9 99       	sbic	0x1f, 1	; 31
 da4:	fe cf       	rjmp	.-4      	; 0xda2 <main+0x188>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 da6:	32 bd       	out	0x22, r19	; 34
 da8:	21 bd       	out	0x21, r18	; 33
#endif
    EECR |= (1 << EERE);
 daa:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 dac:	80 b5       	in	r24, 0x20	; 32
		for (uint8_t i = 0; i < 4; i++) {
			Isb_Msg.Data[i + 1] = lib_eep_read_byte((uint8_t *)(EEP__ISB_NODE_SERIAL_NUMBER_0 + i));
 dae:	81 93       	st	Z+, r24
 db0:	2f 5f       	subi	r18, 0xFF	; 255
 db2:	3f 4f       	sbci	r19, 0xFF	; 255
		Isb_Msg_t Isb_Msg;
		Isb_Msg.Flags = ISB_MSG_FLAGS_TOF_MULTICAST | ISB_MSG_FLAGS_DLC_7;
		Isb_Msg.DestId = ISB_MSG_MULTICAST_GROUPID_FW_START;
		Isb_Msg.SourceId = Isb_Node_Id;
		Isb_Msg.Data[0] = ISB_MSG_TOP__SERIAL_NUMBER__MODE__ERROR;
		for (uint8_t i = 0; i < 4; i++) {
 db4:	28 30       	cpi	r18, 0x08	; 8
 db6:	31 05       	cpc	r19, r1
 db8:	a1 f7       	brne	.-24     	; 0xda2 <main+0x188>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 dba:	f9 99       	sbic	0x1f, 1	; 31
 dbc:	fe cf       	rjmp	.-4      	; 0xdba <main+0x1a0>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 dbe:	82 e1       	ldi	r24, 0x12	; 18
 dc0:	90 e0       	ldi	r25, 0x00	; 0
 dc2:	92 bd       	out	0x22, r25	; 34
 dc4:	81 bd       	out	0x21, r24	; 33
#endif
    EECR |= (1 << EERE);
 dc6:	f8 9a       	sbi	0x1f, 0	; 31
    return EEDR;
 dc8:	80 b5       	in	r24, 0x20	; 32
			Isb_Msg.Data[i + 1] = lib_eep_read_byte((uint8_t *)(EEP__ISB_NODE_SERIAL_NUMBER_0 + i));
		}
		Isb_Msg.Data[5] = lib_eep_read_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE);
 dca:	8b 87       	std	Y+11, r24	; 0x0b
		Isb_Msg.Data[6] = Error;
 dcc:	4c 87       	std	Y+12, r20	; 0x0c
			Isb_Inf_Can_Init(2);
		#endif /* ISB_INF_CAN2 == 1 */
		Isb_Msg_t Isb_Msg;
		Isb_Msg.Flags = ISB_MSG_FLAGS_TOF_MULTICAST | ISB_MSG_FLAGS_DLC_7;
		Isb_Msg.DestId = ISB_MSG_MULTICAST_GROUPID_FW_START;
		Isb_Msg.SourceId = Isb_Node_Id;
 dce:	7d 83       	std	Y+5, r23	; 0x05
 dd0:	6c 83       	std	Y+4, r22	; 0x04
		#if ISB_INF_CAN2 == 1
			Isb_Inf_Can_Init(2);
		#endif /* ISB_INF_CAN2 == 1 */
		Isb_Msg_t Isb_Msg;
		Isb_Msg.Flags = ISB_MSG_FLAGS_TOF_MULTICAST | ISB_MSG_FLAGS_DLC_7;
		Isb_Msg.DestId = ISB_MSG_MULTICAST_GROUPID_FW_START;
 dd2:	82 e0       	ldi	r24, 0x02	; 2
 dd4:	90 ef       	ldi	r25, 0xF0	; 240
 dd6:	9b 83       	std	Y+3, r25	; 0x03
 dd8:	8a 83       	std	Y+2, r24	; 0x02
		#endif /* ISB_INF_CAN1 == 1 */
		#if ISB_INF_CAN2 == 1
			Isb_Inf_Can_Init(2);
		#endif /* ISB_INF_CAN2 == 1 */
		Isb_Msg_t Isb_Msg;
		Isb_Msg.Flags = ISB_MSG_FLAGS_TOF_MULTICAST | ISB_MSG_FLAGS_DLC_7;
 dda:	87 e2       	ldi	r24, 0x27	; 39
 ddc:	89 83       	std	Y+1, r24	; 0x01
		for (uint8_t i = 0; i < 4; i++) {
			Isb_Msg.Data[i + 1] = lib_eep_read_byte((uint8_t *)(EEP__ISB_NODE_SERIAL_NUMBER_0 + i));
		}
		Isb_Msg.Data[5] = lib_eep_read_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE);
		Isb_Msg.Data[6] = Error;
		Isb_SendMsg(&Isb_Msg);
 dde:	8e 01       	movw	r16, r28
 de0:	0f 5f       	subi	r16, 0xFF	; 255
 de2:	1f 4f       	sbci	r17, 0xFF	; 255
 de4:	c8 01       	movw	r24, r16
 de6:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <Isb_SendMsg>
		for (;;) {
			wdt_reset();
			#if ISB_INF_USART0 == 1
				if (Isb_Inf_Usart_Rx(0, &Isb_Msg) == TRUE) {
 dea:	f0 2e       	mov	r15, r16
 dec:	01 2f       	mov	r16, r17
		}
		Isb_Msg.Data[5] = lib_eep_read_byte((uint8_t *)EEP__ISB_NODE_OPERATING_MODE);
		Isb_Msg.Data[6] = Error;
		Isb_SendMsg(&Isb_Msg);
		for (;;) {
			wdt_reset();
 dee:	a8 95       	wdr
			#if ISB_INF_USART0 == 1
				if (Isb_Inf_Usart_Rx(0, &Isb_Msg) == TRUE) {
 df0:	80 e0       	ldi	r24, 0x00	; 0
 df2:	6f 2d       	mov	r22, r15
 df4:	70 2f       	mov	r23, r16
 df6:	0e 94 11 03 	call	0x622	; 0x622 <Isb_Inf_Usart_Rx>
 dfa:	81 30       	cpi	r24, 0x01	; 1
 dfc:	c1 f7       	brne	.-16     	; 0xdee <main+0x1d4>
						Isb_Inf_Can_Tx(1, &Isb_Msg);
					#endif /* ISB_INF_CAN1 == 1 */
					#if ISB_INF_CAN2 == 1
						Isb_Inf_Can_Tx(2, &Isb_Msg);
					#endif /* ISB_INF_CAN2 == 1 */
					if ((Isb_Msg.Flags & ISB_MSG_FLAGS_TOF_MASK) == ISB_MSG_FLAGS_TOF_UNICAST) {
 dfe:	89 81       	ldd	r24, Y+1	; 0x01
 e00:	80 73       	andi	r24, 0x30	; 48
 e02:	a9 f7       	brne	.-22     	; 0xdee <main+0x1d4>
						if (Isb_Msg.DestId == Isb_Node_Id) {
 e04:	2a 81       	ldd	r18, Y+2	; 0x02
 e06:	3b 81       	ldd	r19, Y+3	; 0x03
 e08:	80 91 34 01 	lds	r24, 0x0134
 e0c:	90 91 35 01 	lds	r25, 0x0135
 e10:	28 17       	cp	r18, r24
 e12:	39 07       	cpc	r19, r25
 e14:	61 f7       	brne	.-40     	; 0xdee <main+0x1d4>
							Isb_Config_Rx(&Isb_Msg);
 e16:	8f 2d       	mov	r24, r15
 e18:	90 2f       	mov	r25, r16
 e1a:	0e 94 60 04 	call	0x8c0	; 0x8c0 <Isb_Config_Rx>
 e1e:	e7 cf       	rjmp	.-50     	; 0xdee <main+0x1d4>

00000e20 <__eerd_word>:
 e20:	df 92       	push	r13
 e22:	ef 92       	push	r14
 e24:	ff 92       	push	r15
 e26:	0f 93       	push	r16
 e28:	1f 93       	push	r17
 e2a:	7b 01       	movw	r14, r22
 e2c:	8c 01       	movw	r16, r24
 e2e:	fb 01       	movw	r30, r22
 e30:	09 95       	icall
 e32:	d8 2e       	mov	r13, r24
 e34:	c8 01       	movw	r24, r16
 e36:	01 96       	adiw	r24, 0x01	; 1
 e38:	f7 01       	movw	r30, r14
 e3a:	09 95       	icall
 e3c:	98 2f       	mov	r25, r24
 e3e:	8d 2d       	mov	r24, r13
 e40:	1f 91       	pop	r17
 e42:	0f 91       	pop	r16
 e44:	ff 90       	pop	r15
 e46:	ef 90       	pop	r14
 e48:	df 90       	pop	r13
 e4a:	08 95       	ret

00000e4c <_exit>:
 e4c:	f8 94       	cli

00000e4e <__stop_program>:
 e4e:	ff cf       	rjmp	.-2      	; 0xe4e <__stop_program>
